{
  "language": "Solidity",
  "sources": {
    "@openzeppelin/contracts-upgradeable/access/IAccessControlUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (access/IAccessControl.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev External interface of AccessControl declared to support ERC165 detection.\n */\ninterface IAccessControlUpgradeable {\n    /**\n     * @dev Emitted when `newAdminRole` is set as ``role``'s admin role, replacing `previousAdminRole`\n     *\n     * `DEFAULT_ADMIN_ROLE` is the starting admin for all roles, despite\n     * {RoleAdminChanged} not being emitted signaling this.\n     *\n     * _Available since v3.1._\n     */\n    event RoleAdminChanged(bytes32 indexed role, bytes32 indexed previousAdminRole, bytes32 indexed newAdminRole);\n\n    /**\n     * @dev Emitted when `account` is granted `role`.\n     *\n     * `sender` is the account that originated the contract call, an admin role\n     * bearer except when using {AccessControl-_setupRole}.\n     */\n    event RoleGranted(bytes32 indexed role, address indexed account, address indexed sender);\n\n    /**\n     * @dev Emitted when `account` is revoked `role`.\n     *\n     * `sender` is the account that originated the contract call:\n     *   - if using `revokeRole`, it is the admin role bearer\n     *   - if using `renounceRole`, it is the role bearer (i.e. `account`)\n     */\n    event RoleRevoked(bytes32 indexed role, address indexed account, address indexed sender);\n\n    /**\n     * @dev Returns `true` if `account` has been granted `role`.\n     */\n    function hasRole(bytes32 role, address account) external view returns (bool);\n\n    /**\n     * @dev Returns the admin role that controls `role`. See {grantRole} and\n     * {revokeRole}.\n     *\n     * To change a role's admin, use {AccessControl-_setRoleAdmin}.\n     */\n    function getRoleAdmin(bytes32 role) external view returns (bytes32);\n\n    /**\n     * @dev Grants `role` to `account`.\n     *\n     * If `account` had not been already granted `role`, emits a {RoleGranted}\n     * event.\n     *\n     * Requirements:\n     *\n     * - the caller must have ``role``'s admin role.\n     */\n    function grantRole(bytes32 role, address account) external;\n\n    /**\n     * @dev Revokes `role` from `account`.\n     *\n     * If `account` had been granted `role`, emits a {RoleRevoked} event.\n     *\n     * Requirements:\n     *\n     * - the caller must have ``role``'s admin role.\n     */\n    function revokeRole(bytes32 role, address account) external;\n\n    /**\n     * @dev Revokes `role` from the calling account.\n     *\n     * Roles are often managed via {grantRole} and {revokeRole}: this function's\n     * purpose is to provide a mechanism for accounts to lose their privileges\n     * if they are compromised (such as when a trusted device is misplaced).\n     *\n     * If the calling account had been granted `role`, emits a {RoleRevoked}\n     * event.\n     *\n     * Requirements:\n     *\n     * - the caller must be `account`.\n     */\n    function renounceRole(bytes32 role, address account) external;\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (access/Ownable.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../utils/ContextUpgradeable.sol\";\nimport \"../proxy/utils/Initializable.sol\";\n\n/**\n * @dev Contract module which provides a basic access control mechanism, where\n * there is an account (an owner) that can be granted exclusive access to\n * specific functions.\n *\n * By default, the owner account will be the one that deploys the contract. This\n * can later be changed with {transferOwnership}.\n *\n * This module is used through inheritance. It will make available the modifier\n * `onlyOwner`, which can be applied to your functions to restrict their use to\n * the owner.\n */\nabstract contract OwnableUpgradeable is Initializable, ContextUpgradeable {\n    address private _owner;\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev Initializes the contract setting the deployer as the initial owner.\n     */\n    function __Ownable_init() internal onlyInitializing {\n        __Ownable_init_unchained();\n    }\n\n    function __Ownable_init_unchained() internal onlyInitializing {\n        _transferOwnership(_msgSender());\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        _checkOwner();\n        _;\n    }\n\n    /**\n     * @dev Returns the address of the current owner.\n     */\n    function owner() public view virtual returns (address) {\n        return _owner;\n    }\n\n    /**\n     * @dev Throws if the sender is not the owner.\n     */\n    function _checkOwner() internal view virtual {\n        require(owner() == _msgSender(), \"Ownable: caller is not the owner\");\n    }\n\n    /**\n     * @dev Leaves the contract without owner. It will not be possible to call\n     * `onlyOwner` functions. Can only be called by the current owner.\n     *\n     * NOTE: Renouncing ownership will leave the contract without an owner,\n     * thereby disabling any functionality that is only available to the owner.\n     */\n    function renounceOwnership() public virtual onlyOwner {\n        _transferOwnership(address(0));\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\n        _transferOwnership(newOwner);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Internal function without access restriction.\n     */\n    function _transferOwnership(address newOwner) internal virtual {\n        address oldOwner = _owner;\n        _owner = newOwner;\n        emit OwnershipTransferred(oldOwner, newOwner);\n    }\n\n    /**\n     * @dev This empty reserved space is put in place to allow future versions to add new\n     * variables without shifting down storage in the inheritance chain.\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\n     */\n    uint256[49] private __gap;\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (proxy/utils/Initializable.sol)\n\npragma solidity ^0.8.2;\n\nimport \"../../utils/AddressUpgradeable.sol\";\n\n/**\n * @dev This is a base contract to aid in writing upgradeable contracts, or any kind of contract that will be deployed\n * behind a proxy. Since proxied contracts do not make use of a constructor, it's common to move constructor logic to an\n * external initializer function, usually called `initialize`. It then becomes necessary to protect this initializer\n * function so it can only be called once. The {initializer} modifier provided by this contract will have this effect.\n *\n * The initialization functions use a version number. Once a version number is used, it is consumed and cannot be\n * reused. This mechanism prevents re-execution of each \"step\" but allows the creation of new initialization steps in\n * case an upgrade adds a module that needs to be initialized.\n *\n * For example:\n *\n * [.hljs-theme-light.nopadding]\n * ```solidity\n * contract MyToken is ERC20Upgradeable {\n *     function initialize() initializer public {\n *         __ERC20_init(\"MyToken\", \"MTK\");\n *     }\n * }\n *\n * contract MyTokenV2 is MyToken, ERC20PermitUpgradeable {\n *     function initializeV2() reinitializer(2) public {\n *         __ERC20Permit_init(\"MyToken\");\n *     }\n * }\n * ```\n *\n * TIP: To avoid leaving the proxy in an uninitialized state, the initializer function should be called as early as\n * possible by providing the encoded function call as the `_data` argument to {ERC1967Proxy-constructor}.\n *\n * CAUTION: When used with inheritance, manual care must be taken to not invoke a parent initializer twice, or to ensure\n * that all initializers are idempotent. This is not verified automatically as constructors are by Solidity.\n *\n * [CAUTION]\n * ====\n * Avoid leaving a contract uninitialized.\n *\n * An uninitialized contract can be taken over by an attacker. This applies to both a proxy and its implementation\n * contract, which may impact the proxy. To prevent the implementation contract from being used, you should invoke\n * the {_disableInitializers} function in the constructor to automatically lock it when it is deployed:\n *\n * [.hljs-theme-light.nopadding]\n * ```\n * /// @custom:oz-upgrades-unsafe-allow constructor\n * constructor() {\n *     _disableInitializers();\n * }\n * ```\n * ====\n */\nabstract contract Initializable {\n    /**\n     * @dev Indicates that the contract has been initialized.\n     * @custom:oz-retyped-from bool\n     */\n    uint8 private _initialized;\n\n    /**\n     * @dev Indicates that the contract is in the process of being initialized.\n     */\n    bool private _initializing;\n\n    /**\n     * @dev Triggered when the contract has been initialized or reinitialized.\n     */\n    event Initialized(uint8 version);\n\n    /**\n     * @dev A modifier that defines a protected initializer function that can be invoked at most once. In its scope,\n     * `onlyInitializing` functions can be used to initialize parent contracts.\n     *\n     * Similar to `reinitializer(1)`, except that functions marked with `initializer` can be nested in the context of a\n     * constructor.\n     *\n     * Emits an {Initialized} event.\n     */\n    modifier initializer() {\n        bool isTopLevelCall = !_initializing;\n        require(\n            (isTopLevelCall && _initialized < 1) || (!AddressUpgradeable.isContract(address(this)) && _initialized == 1),\n            \"Initializable: contract is already initialized\"\n        );\n        _initialized = 1;\n        if (isTopLevelCall) {\n            _initializing = true;\n        }\n        _;\n        if (isTopLevelCall) {\n            _initializing = false;\n            emit Initialized(1);\n        }\n    }\n\n    /**\n     * @dev A modifier that defines a protected reinitializer function that can be invoked at most once, and only if the\n     * contract hasn't been initialized to a greater version before. In its scope, `onlyInitializing` functions can be\n     * used to initialize parent contracts.\n     *\n     * A reinitializer may be used after the original initialization step. This is essential to configure modules that\n     * are added through upgrades and that require initialization.\n     *\n     * When `version` is 1, this modifier is similar to `initializer`, except that functions marked with `reinitializer`\n     * cannot be nested. If one is invoked in the context of another, execution will revert.\n     *\n     * Note that versions can jump in increments greater than 1; this implies that if multiple reinitializers coexist in\n     * a contract, executing them in the right order is up to the developer or operator.\n     *\n     * WARNING: setting the version to 255 will prevent any future reinitialization.\n     *\n     * Emits an {Initialized} event.\n     */\n    modifier reinitializer(uint8 version) {\n        require(!_initializing && _initialized < version, \"Initializable: contract is already initialized\");\n        _initialized = version;\n        _initializing = true;\n        _;\n        _initializing = false;\n        emit Initialized(version);\n    }\n\n    /**\n     * @dev Modifier to protect an initialization function so that it can only be invoked by functions with the\n     * {initializer} and {reinitializer} modifiers, directly or indirectly.\n     */\n    modifier onlyInitializing() {\n        require(_initializing, \"Initializable: contract is not initializing\");\n        _;\n    }\n\n    /**\n     * @dev Locks the contract, preventing any future reinitialization. This cannot be part of an initializer call.\n     * Calling this in the constructor of a contract will prevent that contract from being initialized or reinitialized\n     * to any version. It is recommended to use this to lock implementation contracts that are designed to be called\n     * through proxies.\n     *\n     * Emits an {Initialized} event the first time it is successfully executed.\n     */\n    function _disableInitializers() internal virtual {\n        require(!_initializing, \"Initializable: contract is initializing\");\n        if (_initialized != type(uint8).max) {\n            _initialized = type(uint8).max;\n            emit Initialized(type(uint8).max);\n        }\n    }\n\n    /**\n     * @dev Returns the highest version that has been initialized. See {reinitializer}.\n     */\n    function _getInitializedVersion() internal view returns (uint8) {\n        return _initialized;\n    }\n\n    /**\n     * @dev Returns `true` if the contract is currently initializing. See {onlyInitializing}.\n     */\n    function _isInitializing() internal view returns (bool) {\n        return _initializing;\n    }\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/security/PausableUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.7.0) (security/Pausable.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../utils/ContextUpgradeable.sol\";\nimport \"../proxy/utils/Initializable.sol\";\n\n/**\n * @dev Contract module which allows children to implement an emergency stop\n * mechanism that can be triggered by an authorized account.\n *\n * This module is used through inheritance. It will make available the\n * modifiers `whenNotPaused` and `whenPaused`, which can be applied to\n * the functions of your contract. Note that they will not be pausable by\n * simply including this module, only once the modifiers are put in place.\n */\nabstract contract PausableUpgradeable is Initializable, ContextUpgradeable {\n    /**\n     * @dev Emitted when the pause is triggered by `account`.\n     */\n    event Paused(address account);\n\n    /**\n     * @dev Emitted when the pause is lifted by `account`.\n     */\n    event Unpaused(address account);\n\n    bool private _paused;\n\n    /**\n     * @dev Initializes the contract in unpaused state.\n     */\n    function __Pausable_init() internal onlyInitializing {\n        __Pausable_init_unchained();\n    }\n\n    function __Pausable_init_unchained() internal onlyInitializing {\n        _paused = false;\n    }\n\n    /**\n     * @dev Modifier to make a function callable only when the contract is not paused.\n     *\n     * Requirements:\n     *\n     * - The contract must not be paused.\n     */\n    modifier whenNotPaused() {\n        _requireNotPaused();\n        _;\n    }\n\n    /**\n     * @dev Modifier to make a function callable only when the contract is paused.\n     *\n     * Requirements:\n     *\n     * - The contract must be paused.\n     */\n    modifier whenPaused() {\n        _requirePaused();\n        _;\n    }\n\n    /**\n     * @dev Returns true if the contract is paused, and false otherwise.\n     */\n    function paused() public view virtual returns (bool) {\n        return _paused;\n    }\n\n    /**\n     * @dev Throws if the contract is paused.\n     */\n    function _requireNotPaused() internal view virtual {\n        require(!paused(), \"Pausable: paused\");\n    }\n\n    /**\n     * @dev Throws if the contract is not paused.\n     */\n    function _requirePaused() internal view virtual {\n        require(paused(), \"Pausable: not paused\");\n    }\n\n    /**\n     * @dev Triggers stopped state.\n     *\n     * Requirements:\n     *\n     * - The contract must not be paused.\n     */\n    function _pause() internal virtual whenNotPaused {\n        _paused = true;\n        emit Paused(_msgSender());\n    }\n\n    /**\n     * @dev Returns to normal state.\n     *\n     * Requirements:\n     *\n     * - The contract must be paused.\n     */\n    function _unpause() internal virtual whenPaused {\n        _paused = false;\n        emit Unpaused(_msgSender());\n    }\n\n    /**\n     * @dev This empty reserved space is put in place to allow future versions to add new\n     * variables without shifting down storage in the inheritance chain.\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\n     */\n    uint256[49] private __gap;\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/security/ReentrancyGuardUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (security/ReentrancyGuard.sol)\n\npragma solidity ^0.8.0;\nimport \"../proxy/utils/Initializable.sol\";\n\n/**\n * @dev Contract module that helps prevent reentrant calls to a function.\n *\n * Inheriting from `ReentrancyGuard` will make the {nonReentrant} modifier\n * available, which can be applied to functions to make sure there are no nested\n * (reentrant) calls to them.\n *\n * Note that because there is a single `nonReentrant` guard, functions marked as\n * `nonReentrant` may not call one another. This can be worked around by making\n * those functions `private`, and then adding `external` `nonReentrant` entry\n * points to them.\n *\n * TIP: If you would like to learn more about reentrancy and alternative ways\n * to protect against it, check out our blog post\n * https://blog.openzeppelin.com/reentrancy-after-istanbul/[Reentrancy After Istanbul].\n */\nabstract contract ReentrancyGuardUpgradeable is Initializable {\n    // Booleans are more expensive than uint256 or any type that takes up a full\n    // word because each write operation emits an extra SLOAD to first read the\n    // slot's contents, replace the bits taken up by the boolean, and then write\n    // back. This is the compiler's defense against contract upgrades and\n    // pointer aliasing, and it cannot be disabled.\n\n    // The values being non-zero value makes deployment a bit more expensive,\n    // but in exchange the refund on every call to nonReentrant will be lower in\n    // amount. Since refunds are capped to a percentage of the total\n    // transaction's gas, it is best to keep them low in cases like this one, to\n    // increase the likelihood of the full refund coming into effect.\n    uint256 private constant _NOT_ENTERED = 1;\n    uint256 private constant _ENTERED = 2;\n\n    uint256 private _status;\n\n    function __ReentrancyGuard_init() internal onlyInitializing {\n        __ReentrancyGuard_init_unchained();\n    }\n\n    function __ReentrancyGuard_init_unchained() internal onlyInitializing {\n        _status = _NOT_ENTERED;\n    }\n\n    /**\n     * @dev Prevents a contract from calling itself, directly or indirectly.\n     * Calling a `nonReentrant` function from another `nonReentrant`\n     * function is not supported. It is possible to prevent this from happening\n     * by making the `nonReentrant` function external, and making it call a\n     * `private` function that does the actual work.\n     */\n    modifier nonReentrant() {\n        _nonReentrantBefore();\n        _;\n        _nonReentrantAfter();\n    }\n\n    function _nonReentrantBefore() private {\n        // On the first call to nonReentrant, _status will be _NOT_ENTERED\n        require(_status != _ENTERED, \"ReentrancyGuard: reentrant call\");\n\n        // Any calls to nonReentrant after this point will fail\n        _status = _ENTERED;\n    }\n\n    function _nonReentrantAfter() private {\n        // By storing the original value once again, a refund is triggered (see\n        // https://eips.ethereum.org/EIPS/eip-2200)\n        _status = _NOT_ENTERED;\n    }\n\n    /**\n     * @dev Returns true if the reentrancy guard is currently set to \"entered\", which indicates there is a\n     * `nonReentrant` function in the call stack.\n     */\n    function _reentrancyGuardEntered() internal view returns (bool) {\n        return _status == _ENTERED;\n    }\n\n    /**\n     * @dev This empty reserved space is put in place to allow future versions to add new\n     * variables without shifting down storage in the inheritance chain.\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\n     */\n    uint256[49] private __gap;\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/token/ERC721/IERC721Upgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (token/ERC721/IERC721.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../../utils/introspection/IERC165Upgradeable.sol\";\n\n/**\n * @dev Required interface of an ERC721 compliant contract.\n */\ninterface IERC721Upgradeable is IERC165Upgradeable {\n    /**\n     * @dev Emitted when `tokenId` token is transferred from `from` to `to`.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);\n\n    /**\n     * @dev Emitted when `owner` enables `approved` to manage the `tokenId` token.\n     */\n    event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);\n\n    /**\n     * @dev Emitted when `owner` enables or disables (`approved`) `operator` to manage all of its assets.\n     */\n    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\n\n    /**\n     * @dev Returns the number of tokens in ``owner``'s account.\n     */\n    function balanceOf(address owner) external view returns (uint256 balance);\n\n    /**\n     * @dev Returns the owner of the `tokenId` token.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     */\n    function ownerOf(uint256 tokenId) external view returns (address owner);\n\n    /**\n     * @dev Safely transfers `tokenId` token from `from` to `to`.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must exist and be owned by `from`.\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\n     *\n     * Emits a {Transfer} event.\n     */\n    function safeTransferFrom(address from, address to, uint256 tokenId, bytes calldata data) external;\n\n    /**\n     * @dev Safely transfers `tokenId` token from `from` to `to`, checking first that contract recipients\n     * are aware of the ERC721 protocol to prevent tokens from being forever locked.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must exist and be owned by `from`.\n     * - If the caller is not `from`, it must have been allowed to move this token by either {approve} or {setApprovalForAll}.\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\n     *\n     * Emits a {Transfer} event.\n     */\n    function safeTransferFrom(address from, address to, uint256 tokenId) external;\n\n    /**\n     * @dev Transfers `tokenId` token from `from` to `to`.\n     *\n     * WARNING: Note that the caller is responsible to confirm that the recipient is capable of receiving ERC721\n     * or else they may be permanently lost. Usage of {safeTransferFrom} prevents loss, though the caller must\n     * understand this adds an external call which potentially creates a reentrancy vulnerability.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must be owned by `from`.\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(address from, address to, uint256 tokenId) external;\n\n    /**\n     * @dev Gives permission to `to` to transfer `tokenId` token to another account.\n     * The approval is cleared when the token is transferred.\n     *\n     * Only a single account can be approved at a time, so approving the zero address clears previous approvals.\n     *\n     * Requirements:\n     *\n     * - The caller must own the token or be an approved operator.\n     * - `tokenId` must exist.\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address to, uint256 tokenId) external;\n\n    /**\n     * @dev Approve or remove `operator` as an operator for the caller.\n     * Operators can call {transferFrom} or {safeTransferFrom} for any token owned by the caller.\n     *\n     * Requirements:\n     *\n     * - The `operator` cannot be the caller.\n     *\n     * Emits an {ApprovalForAll} event.\n     */\n    function setApprovalForAll(address operator, bool approved) external;\n\n    /**\n     * @dev Returns the account approved for `tokenId` token.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     */\n    function getApproved(uint256 tokenId) external view returns (address operator);\n\n    /**\n     * @dev Returns if the `operator` is allowed to manage all of the assets of `owner`.\n     *\n     * See {setApprovalForAll}\n     */\n    function isApprovedForAll(address owner, address operator) external view returns (bool);\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/utils/AddressUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (utils/Address.sol)\n\npragma solidity ^0.8.1;\n\n/**\n * @dev Collection of functions related to the address type\n */\nlibrary AddressUpgradeable {\n    /**\n     * @dev Returns true if `account` is a contract.\n     *\n     * [IMPORTANT]\n     * ====\n     * It is unsafe to assume that an address for which this function returns\n     * false is an externally-owned account (EOA) and not a contract.\n     *\n     * Among others, `isContract` will return false for the following\n     * types of addresses:\n     *\n     *  - an externally-owned account\n     *  - a contract in construction\n     *  - an address where a contract will be created\n     *  - an address where a contract lived, but was destroyed\n     *\n     * Furthermore, `isContract` will also return true if the target contract within\n     * the same transaction is already scheduled for destruction by `SELFDESTRUCT`,\n     * which only has an effect at the end of a transaction.\n     * ====\n     *\n     * [IMPORTANT]\n     * ====\n     * You shouldn't rely on `isContract` to protect against flash loan attacks!\n     *\n     * Preventing calls from contracts is highly discouraged. It breaks composability, breaks support for smart wallets\n     * like Gnosis Safe, and does not provide security since it can be circumvented by calling from a contract\n     * constructor.\n     * ====\n     */\n    function isContract(address account) internal view returns (bool) {\n        // This method relies on extcodesize/address.code.length, which returns 0\n        // for contracts in construction, since the code is only stored at the end\n        // of the constructor execution.\n\n        return account.code.length > 0;\n    }\n\n    /**\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\n     * `recipient`, forwarding all available gas and reverting on errors.\n     *\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\n     * imposed by `transfer`, making them unable to receive funds via\n     * `transfer`. {sendValue} removes this limitation.\n     *\n     * https://consensys.net/diligence/blog/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n     *\n     * IMPORTANT: because control is transferred to `recipient`, care must be\n     * taken to not create reentrancy vulnerabilities. Consider using\n     * {ReentrancyGuard} or the\n     * https://solidity.readthedocs.io/en/v0.8.0/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n     */\n    function sendValue(address payable recipient, uint256 amount) internal {\n        require(address(this).balance >= amount, \"Address: insufficient balance\");\n\n        (bool success, ) = recipient.call{value: amount}(\"\");\n        require(success, \"Address: unable to send value, recipient may have reverted\");\n    }\n\n    /**\n     * @dev Performs a Solidity function call using a low level `call`. A\n     * plain `call` is an unsafe replacement for a function call: use this\n     * function instead.\n     *\n     * If `target` reverts with a revert reason, it is bubbled up by this\n     * function (like regular Solidity function calls).\n     *\n     * Returns the raw returned data. To convert to the expected return value,\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\n     *\n     * Requirements:\n     *\n     * - `target` must be a contract.\n     * - calling `target` with `data` must not revert.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, \"Address: low-level call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\n     * `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but also transferring `value` wei to `target`.\n     *\n     * Requirements:\n     *\n     * - the calling contract must have an ETH balance of at least `value`.\n     * - the called Solidity function must be `payable`.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, value, \"Address: low-level call with value failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        require(address(this).balance >= value, \"Address: insufficient balance for call\");\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n        return functionStaticCall(target, data, \"Address: low-level static call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.staticcall(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionDelegateCall(target, data, \"Address: low-level delegate call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.delegatecall(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Tool to verify that a low level call to smart-contract was successful, and revert (either by bubbling\n     * the revert reason or using the provided one) in case of unsuccessful call or if target was not a contract.\n     *\n     * _Available since v4.8._\n     */\n    function verifyCallResultFromTarget(\n        address target,\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        if (success) {\n            if (returndata.length == 0) {\n                // only check isContract if the call was successful and the return data is empty\n                // otherwise we already know that it was a contract\n                require(isContract(target), \"Address: call to non-contract\");\n            }\n            return returndata;\n        } else {\n            _revert(returndata, errorMessage);\n        }\n    }\n\n    /**\n     * @dev Tool to verify that a low level call was successful, and revert if it wasn't, either by bubbling the\n     * revert reason or using the provided one.\n     *\n     * _Available since v4.3._\n     */\n    function verifyCallResult(\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal pure returns (bytes memory) {\n        if (success) {\n            return returndata;\n        } else {\n            _revert(returndata, errorMessage);\n        }\n    }\n\n    function _revert(bytes memory returndata, string memory errorMessage) private pure {\n        // Look for revert reason and bubble it up if present\n        if (returndata.length > 0) {\n            // The easiest way to bubble the revert reason is using memory via assembly\n            /// @solidity memory-safe-assembly\n            assembly {\n                let returndata_size := mload(returndata)\n                revert(add(32, returndata), returndata_size)\n            }\n        } else {\n            revert(errorMessage);\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/utils/ContextUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/Context.sol)\n\npragma solidity ^0.8.0;\nimport \"../proxy/utils/Initializable.sol\";\n\n/**\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract ContextUpgradeable is Initializable {\n    function __Context_init() internal onlyInitializing {\n    }\n\n    function __Context_init_unchained() internal onlyInitializing {\n    }\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }\n\n    /**\n     * @dev This empty reserved space is put in place to allow future versions to add new\n     * variables without shifting down storage in the inheritance chain.\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\n     */\n    uint256[50] private __gap;\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/utils/introspection/ERC165Upgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/introspection/ERC165.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./IERC165Upgradeable.sol\";\nimport \"../../proxy/utils/Initializable.sol\";\n\n/**\n * @dev Implementation of the {IERC165} interface.\n *\n * Contracts that want to implement ERC165 should inherit from this contract and override {supportsInterface} to check\n * for the additional interface id that will be supported. For example:\n *\n * ```solidity\n * function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n *     return interfaceId == type(MyInterface).interfaceId || super.supportsInterface(interfaceId);\n * }\n * ```\n *\n * Alternatively, {ERC165Storage} provides an easier to use but more expensive implementation.\n */\nabstract contract ERC165Upgradeable is Initializable, IERC165Upgradeable {\n    function __ERC165_init() internal onlyInitializing {\n    }\n\n    function __ERC165_init_unchained() internal onlyInitializing {\n    }\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n        return interfaceId == type(IERC165Upgradeable).interfaceId;\n    }\n\n    /**\n     * @dev This empty reserved space is put in place to allow future versions to add new\n     * variables without shifting down storage in the inheritance chain.\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\n     */\n    uint256[50] private __gap;\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/utils/introspection/IERC165Upgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/introspection/IERC165.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC165 standard, as defined in the\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\n *\n * Implementers can declare support of contract interfaces, which can then be\n * queried by others ({ERC165Checker}).\n *\n * For an implementation, see {ERC165}.\n */\ninterface IERC165Upgradeable {\n    /**\n     * @dev Returns true if this contract implements the interface defined by\n     * `interfaceId`. See the corresponding\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\n     * to learn more about how these ids are created.\n     *\n     * This function call must use less than 30 000 gas.\n     */\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\n}\n"
    },
    "@openzeppelin/contracts/access/Ownable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (access/Ownable.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../utils/Context.sol\";\n\n/**\n * @dev Contract module which provides a basic access control mechanism, where\n * there is an account (an owner) that can be granted exclusive access to\n * specific functions.\n *\n * By default, the owner account will be the one that deploys the contract. This\n * can later be changed with {transferOwnership}.\n *\n * This module is used through inheritance. It will make available the modifier\n * `onlyOwner`, which can be applied to your functions to restrict their use to\n * the owner.\n */\nabstract contract Ownable is Context {\n    address private _owner;\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev Initializes the contract setting the deployer as the initial owner.\n     */\n    constructor() {\n        _transferOwnership(_msgSender());\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        _checkOwner();\n        _;\n    }\n\n    /**\n     * @dev Returns the address of the current owner.\n     */\n    function owner() public view virtual returns (address) {\n        return _owner;\n    }\n\n    /**\n     * @dev Throws if the sender is not the owner.\n     */\n    function _checkOwner() internal view virtual {\n        require(owner() == _msgSender(), \"Ownable: caller is not the owner\");\n    }\n\n    /**\n     * @dev Leaves the contract without owner. It will not be possible to call\n     * `onlyOwner` functions. Can only be called by the current owner.\n     *\n     * NOTE: Renouncing ownership will leave the contract without an owner,\n     * thereby disabling any functionality that is only available to the owner.\n     */\n    function renounceOwnership() public virtual onlyOwner {\n        _transferOwnership(address(0));\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\n        _transferOwnership(newOwner);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Internal function without access restriction.\n     */\n    function _transferOwnership(address newOwner) internal virtual {\n        address oldOwner = _owner;\n        _owner = newOwner;\n        emit OwnershipTransferred(oldOwner, newOwner);\n    }\n}\n"
    },
    "@openzeppelin/contracts/interfaces/draft-IERC1822.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.5.0) (interfaces/draft-IERC1822.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev ERC1822: Universal Upgradeable Proxy Standard (UUPS) documents a method for upgradeability through a simplified\n * proxy whose upgrades are fully controlled by the current implementation.\n */\ninterface IERC1822Proxiable {\n    /**\n     * @dev Returns the storage slot that the proxiable contract assumes is being used to store the implementation\n     * address.\n     *\n     * IMPORTANT: A proxy pointing at a proxiable contract should not be considered proxiable itself, because this risks\n     * bricking a proxy that upgrades to it, by delegating to itself until out of gas. Thus it is critical that this\n     * function revert if invoked through a proxy.\n     */\n    function proxiableUUID() external view returns (bytes32);\n}\n"
    },
    "@openzeppelin/contracts/interfaces/IERC1967.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (interfaces/IERC1967.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev ERC-1967: Proxy Storage Slots. This interface contains the events defined in the ERC.\n *\n * _Available since v4.8.3._\n */\ninterface IERC1967 {\n    /**\n     * @dev Emitted when the implementation is upgraded.\n     */\n    event Upgraded(address indexed implementation);\n\n    /**\n     * @dev Emitted when the admin account has changed.\n     */\n    event AdminChanged(address previousAdmin, address newAdmin);\n\n    /**\n     * @dev Emitted when the beacon is changed.\n     */\n    event BeaconUpgraded(address indexed beacon);\n}\n"
    },
    "@openzeppelin/contracts/proxy/beacon/BeaconProxy.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.7.0) (proxy/beacon/BeaconProxy.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./IBeacon.sol\";\nimport \"../Proxy.sol\";\nimport \"../ERC1967/ERC1967Upgrade.sol\";\n\n/**\n * @dev This contract implements a proxy that gets the implementation address for each call from an {UpgradeableBeacon}.\n *\n * The beacon address is stored in storage slot `uint256(keccak256('eip1967.proxy.beacon')) - 1`, so that it doesn't\n * conflict with the storage layout of the implementation behind the proxy.\n *\n * _Available since v3.4._\n */\ncontract BeaconProxy is Proxy, ERC1967Upgrade {\n    /**\n     * @dev Initializes the proxy with `beacon`.\n     *\n     * If `data` is nonempty, it's used as data in a delegate call to the implementation returned by the beacon. This\n     * will typically be an encoded function call, and allows initializing the storage of the proxy like a Solidity\n     * constructor.\n     *\n     * Requirements:\n     *\n     * - `beacon` must be a contract with the interface {IBeacon}.\n     */\n    constructor(address beacon, bytes memory data) payable {\n        _upgradeBeaconToAndCall(beacon, data, false);\n    }\n\n    /**\n     * @dev Returns the current beacon address.\n     */\n    function _beacon() internal view virtual returns (address) {\n        return _getBeacon();\n    }\n\n    /**\n     * @dev Returns the current implementation address of the associated beacon.\n     */\n    function _implementation() internal view virtual override returns (address) {\n        return IBeacon(_getBeacon()).implementation();\n    }\n\n    /**\n     * @dev Changes the proxy to use a new beacon. Deprecated: see {_upgradeBeaconToAndCall}.\n     *\n     * If `data` is nonempty, it's used as data in a delegate call to the implementation returned by the beacon.\n     *\n     * Requirements:\n     *\n     * - `beacon` must be a contract.\n     * - The implementation returned by `beacon` must be a contract.\n     */\n    function _setBeacon(address beacon, bytes memory data) internal virtual {\n        _upgradeBeaconToAndCall(beacon, data, false);\n    }\n}\n"
    },
    "@openzeppelin/contracts/proxy/beacon/IBeacon.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (proxy/beacon/IBeacon.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev This is the interface that {BeaconProxy} expects of its beacon.\n */\ninterface IBeacon {\n    /**\n     * @dev Must return an address that can be used as a delegate call target.\n     *\n     * {BeaconProxy} will check that this address is a contract.\n     */\n    function implementation() external view returns (address);\n}\n"
    },
    "@openzeppelin/contracts/proxy/beacon/UpgradeableBeacon.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (proxy/beacon/UpgradeableBeacon.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./IBeacon.sol\";\nimport \"../../access/Ownable.sol\";\nimport \"../../utils/Address.sol\";\n\n/**\n * @dev This contract is used in conjunction with one or more instances of {BeaconProxy} to determine their\n * implementation contract, which is where they will delegate all function calls.\n *\n * An owner is able to change the implementation the beacon points to, thus upgrading the proxies that use this beacon.\n */\ncontract UpgradeableBeacon is IBeacon, Ownable {\n    address private _implementation;\n\n    /**\n     * @dev Emitted when the implementation returned by the beacon is changed.\n     */\n    event Upgraded(address indexed implementation);\n\n    /**\n     * @dev Sets the address of the initial implementation, and the deployer account as the owner who can upgrade the\n     * beacon.\n     */\n    constructor(address implementation_) {\n        _setImplementation(implementation_);\n    }\n\n    /**\n     * @dev Returns the current implementation address.\n     */\n    function implementation() public view virtual override returns (address) {\n        return _implementation;\n    }\n\n    /**\n     * @dev Upgrades the beacon to a new implementation.\n     *\n     * Emits an {Upgraded} event.\n     *\n     * Requirements:\n     *\n     * - msg.sender must be the owner of the contract.\n     * - `newImplementation` must be a contract.\n     */\n    function upgradeTo(address newImplementation) public virtual onlyOwner {\n        _setImplementation(newImplementation);\n        emit Upgraded(newImplementation);\n    }\n\n    /**\n     * @dev Sets the implementation contract address for this beacon\n     *\n     * Requirements:\n     *\n     * - `newImplementation` must be a contract.\n     */\n    function _setImplementation(address newImplementation) private {\n        require(Address.isContract(newImplementation), \"UpgradeableBeacon: implementation is not a contract\");\n        _implementation = newImplementation;\n    }\n}\n"
    },
    "@openzeppelin/contracts/proxy/ERC1967/ERC1967Upgrade.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (proxy/ERC1967/ERC1967Upgrade.sol)\n\npragma solidity ^0.8.2;\n\nimport \"../beacon/IBeacon.sol\";\nimport \"../../interfaces/IERC1967.sol\";\nimport \"../../interfaces/draft-IERC1822.sol\";\nimport \"../../utils/Address.sol\";\nimport \"../../utils/StorageSlot.sol\";\n\n/**\n * @dev This abstract contract provides getters and event emitting update functions for\n * https://eips.ethereum.org/EIPS/eip-1967[EIP1967] slots.\n *\n * _Available since v4.1._\n */\nabstract contract ERC1967Upgrade is IERC1967 {\n    // This is the keccak-256 hash of \"eip1967.proxy.rollback\" subtracted by 1\n    bytes32 private constant _ROLLBACK_SLOT = 0x4910fdfa16fed3260ed0e7147f7cc6da11a60208b5b9406d12a635614ffd9143;\n\n    /**\n     * @dev Storage slot with the address of the current implementation.\n     * This is the keccak-256 hash of \"eip1967.proxy.implementation\" subtracted by 1, and is\n     * validated in the constructor.\n     */\n    bytes32 internal constant _IMPLEMENTATION_SLOT = 0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc;\n\n    /**\n     * @dev Returns the current implementation address.\n     */\n    function _getImplementation() internal view returns (address) {\n        return StorageSlot.getAddressSlot(_IMPLEMENTATION_SLOT).value;\n    }\n\n    /**\n     * @dev Stores a new address in the EIP1967 implementation slot.\n     */\n    function _setImplementation(address newImplementation) private {\n        require(Address.isContract(newImplementation), \"ERC1967: new implementation is not a contract\");\n        StorageSlot.getAddressSlot(_IMPLEMENTATION_SLOT).value = newImplementation;\n    }\n\n    /**\n     * @dev Perform implementation upgrade\n     *\n     * Emits an {Upgraded} event.\n     */\n    function _upgradeTo(address newImplementation) internal {\n        _setImplementation(newImplementation);\n        emit Upgraded(newImplementation);\n    }\n\n    /**\n     * @dev Perform implementation upgrade with additional setup call.\n     *\n     * Emits an {Upgraded} event.\n     */\n    function _upgradeToAndCall(address newImplementation, bytes memory data, bool forceCall) internal {\n        _upgradeTo(newImplementation);\n        if (data.length > 0 || forceCall) {\n            Address.functionDelegateCall(newImplementation, data);\n        }\n    }\n\n    /**\n     * @dev Perform implementation upgrade with security checks for UUPS proxies, and additional setup call.\n     *\n     * Emits an {Upgraded} event.\n     */\n    function _upgradeToAndCallUUPS(address newImplementation, bytes memory data, bool forceCall) internal {\n        // Upgrades from old implementations will perform a rollback test. This test requires the new\n        // implementation to upgrade back to the old, non-ERC1822 compliant, implementation. Removing\n        // this special case will break upgrade paths from old UUPS implementation to new ones.\n        if (StorageSlot.getBooleanSlot(_ROLLBACK_SLOT).value) {\n            _setImplementation(newImplementation);\n        } else {\n            try IERC1822Proxiable(newImplementation).proxiableUUID() returns (bytes32 slot) {\n                require(slot == _IMPLEMENTATION_SLOT, \"ERC1967Upgrade: unsupported proxiableUUID\");\n            } catch {\n                revert(\"ERC1967Upgrade: new implementation is not UUPS\");\n            }\n            _upgradeToAndCall(newImplementation, data, forceCall);\n        }\n    }\n\n    /**\n     * @dev Storage slot with the admin of the contract.\n     * This is the keccak-256 hash of \"eip1967.proxy.admin\" subtracted by 1, and is\n     * validated in the constructor.\n     */\n    bytes32 internal constant _ADMIN_SLOT = 0xb53127684a568b3173ae13b9f8a6016e243e63b6e8ee1178d6a717850b5d6103;\n\n    /**\n     * @dev Returns the current admin.\n     */\n    function _getAdmin() internal view returns (address) {\n        return StorageSlot.getAddressSlot(_ADMIN_SLOT).value;\n    }\n\n    /**\n     * @dev Stores a new address in the EIP1967 admin slot.\n     */\n    function _setAdmin(address newAdmin) private {\n        require(newAdmin != address(0), \"ERC1967: new admin is the zero address\");\n        StorageSlot.getAddressSlot(_ADMIN_SLOT).value = newAdmin;\n    }\n\n    /**\n     * @dev Changes the admin of the proxy.\n     *\n     * Emits an {AdminChanged} event.\n     */\n    function _changeAdmin(address newAdmin) internal {\n        emit AdminChanged(_getAdmin(), newAdmin);\n        _setAdmin(newAdmin);\n    }\n\n    /**\n     * @dev The storage slot of the UpgradeableBeacon contract which defines the implementation for this proxy.\n     * This is bytes32(uint256(keccak256('eip1967.proxy.beacon')) - 1)) and is validated in the constructor.\n     */\n    bytes32 internal constant _BEACON_SLOT = 0xa3f0ad74e5423aebfd80d3ef4346578335a9a72aeaee59ff6cb3582b35133d50;\n\n    /**\n     * @dev Returns the current beacon.\n     */\n    function _getBeacon() internal view returns (address) {\n        return StorageSlot.getAddressSlot(_BEACON_SLOT).value;\n    }\n\n    /**\n     * @dev Stores a new beacon in the EIP1967 beacon slot.\n     */\n    function _setBeacon(address newBeacon) private {\n        require(Address.isContract(newBeacon), \"ERC1967: new beacon is not a contract\");\n        require(\n            Address.isContract(IBeacon(newBeacon).implementation()),\n            \"ERC1967: beacon implementation is not a contract\"\n        );\n        StorageSlot.getAddressSlot(_BEACON_SLOT).value = newBeacon;\n    }\n\n    /**\n     * @dev Perform beacon upgrade with additional setup call. Note: This upgrades the address of the beacon, it does\n     * not upgrade the implementation contained in the beacon (see {UpgradeableBeacon-_setImplementation} for that).\n     *\n     * Emits a {BeaconUpgraded} event.\n     */\n    function _upgradeBeaconToAndCall(address newBeacon, bytes memory data, bool forceCall) internal {\n        _setBeacon(newBeacon);\n        emit BeaconUpgraded(newBeacon);\n        if (data.length > 0 || forceCall) {\n            Address.functionDelegateCall(IBeacon(newBeacon).implementation(), data);\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts/proxy/Proxy.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.6.0) (proxy/Proxy.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev This abstract contract provides a fallback function that delegates all calls to another contract using the EVM\n * instruction `delegatecall`. We refer to the second contract as the _implementation_ behind the proxy, and it has to\n * be specified by overriding the virtual {_implementation} function.\n *\n * Additionally, delegation to the implementation can be triggered manually through the {_fallback} function, or to a\n * different contract through the {_delegate} function.\n *\n * The success and return data of the delegated call will be returned back to the caller of the proxy.\n */\nabstract contract Proxy {\n    /**\n     * @dev Delegates the current call to `implementation`.\n     *\n     * This function does not return to its internal call site, it will return directly to the external caller.\n     */\n    function _delegate(address implementation) internal virtual {\n        assembly {\n            // Copy msg.data. We take full control of memory in this inline assembly\n            // block because it will not return to Solidity code. We overwrite the\n            // Solidity scratch pad at memory position 0.\n            calldatacopy(0, 0, calldatasize())\n\n            // Call the implementation.\n            // out and outsize are 0 because we don't know the size yet.\n            let result := delegatecall(gas(), implementation, 0, calldatasize(), 0, 0)\n\n            // Copy the returned data.\n            returndatacopy(0, 0, returndatasize())\n\n            switch result\n            // delegatecall returns 0 on error.\n            case 0 {\n                revert(0, returndatasize())\n            }\n            default {\n                return(0, returndatasize())\n            }\n        }\n    }\n\n    /**\n     * @dev This is a virtual function that should be overridden so it returns the address to which the fallback function\n     * and {_fallback} should delegate.\n     */\n    function _implementation() internal view virtual returns (address);\n\n    /**\n     * @dev Delegates the current call to the address returned by `_implementation()`.\n     *\n     * This function does not return to its internal call site, it will return directly to the external caller.\n     */\n    function _fallback() internal virtual {\n        _beforeFallback();\n        _delegate(_implementation());\n    }\n\n    /**\n     * @dev Fallback function that delegates calls to the address returned by `_implementation()`. Will run if no other\n     * function in the contract matches the call data.\n     */\n    fallback() external payable virtual {\n        _fallback();\n    }\n\n    /**\n     * @dev Fallback function that delegates calls to the address returned by `_implementation()`. Will run if call data\n     * is empty.\n     */\n    receive() external payable virtual {\n        _fallback();\n    }\n\n    /**\n     * @dev Hook that is called before falling back to the implementation. Can happen as part of a manual `_fallback`\n     * call, or as part of the Solidity `fallback` or `receive` functions.\n     *\n     * If overridden should call `super._beforeFallback()`.\n     */\n    function _beforeFallback() internal virtual {}\n}\n"
    },
    "@openzeppelin/contracts/utils/Address.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (utils/Address.sol)\n\npragma solidity ^0.8.1;\n\n/**\n * @dev Collection of functions related to the address type\n */\nlibrary Address {\n    /**\n     * @dev Returns true if `account` is a contract.\n     *\n     * [IMPORTANT]\n     * ====\n     * It is unsafe to assume that an address for which this function returns\n     * false is an externally-owned account (EOA) and not a contract.\n     *\n     * Among others, `isContract` will return false for the following\n     * types of addresses:\n     *\n     *  - an externally-owned account\n     *  - a contract in construction\n     *  - an address where a contract will be created\n     *  - an address where a contract lived, but was destroyed\n     *\n     * Furthermore, `isContract` will also return true if the target contract within\n     * the same transaction is already scheduled for destruction by `SELFDESTRUCT`,\n     * which only has an effect at the end of a transaction.\n     * ====\n     *\n     * [IMPORTANT]\n     * ====\n     * You shouldn't rely on `isContract` to protect against flash loan attacks!\n     *\n     * Preventing calls from contracts is highly discouraged. It breaks composability, breaks support for smart wallets\n     * like Gnosis Safe, and does not provide security since it can be circumvented by calling from a contract\n     * constructor.\n     * ====\n     */\n    function isContract(address account) internal view returns (bool) {\n        // This method relies on extcodesize/address.code.length, which returns 0\n        // for contracts in construction, since the code is only stored at the end\n        // of the constructor execution.\n\n        return account.code.length > 0;\n    }\n\n    /**\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\n     * `recipient`, forwarding all available gas and reverting on errors.\n     *\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\n     * imposed by `transfer`, making them unable to receive funds via\n     * `transfer`. {sendValue} removes this limitation.\n     *\n     * https://consensys.net/diligence/blog/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n     *\n     * IMPORTANT: because control is transferred to `recipient`, care must be\n     * taken to not create reentrancy vulnerabilities. Consider using\n     * {ReentrancyGuard} or the\n     * https://solidity.readthedocs.io/en/v0.8.0/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n     */\n    function sendValue(address payable recipient, uint256 amount) internal {\n        require(address(this).balance >= amount, \"Address: insufficient balance\");\n\n        (bool success, ) = recipient.call{value: amount}(\"\");\n        require(success, \"Address: unable to send value, recipient may have reverted\");\n    }\n\n    /**\n     * @dev Performs a Solidity function call using a low level `call`. A\n     * plain `call` is an unsafe replacement for a function call: use this\n     * function instead.\n     *\n     * If `target` reverts with a revert reason, it is bubbled up by this\n     * function (like regular Solidity function calls).\n     *\n     * Returns the raw returned data. To convert to the expected return value,\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\n     *\n     * Requirements:\n     *\n     * - `target` must be a contract.\n     * - calling `target` with `data` must not revert.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, \"Address: low-level call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\n     * `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but also transferring `value` wei to `target`.\n     *\n     * Requirements:\n     *\n     * - the calling contract must have an ETH balance of at least `value`.\n     * - the called Solidity function must be `payable`.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, value, \"Address: low-level call with value failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        require(address(this).balance >= value, \"Address: insufficient balance for call\");\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n        return functionStaticCall(target, data, \"Address: low-level static call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.staticcall(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionDelegateCall(target, data, \"Address: low-level delegate call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.delegatecall(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Tool to verify that a low level call to smart-contract was successful, and revert (either by bubbling\n     * the revert reason or using the provided one) in case of unsuccessful call or if target was not a contract.\n     *\n     * _Available since v4.8._\n     */\n    function verifyCallResultFromTarget(\n        address target,\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        if (success) {\n            if (returndata.length == 0) {\n                // only check isContract if the call was successful and the return data is empty\n                // otherwise we already know that it was a contract\n                require(isContract(target), \"Address: call to non-contract\");\n            }\n            return returndata;\n        } else {\n            _revert(returndata, errorMessage);\n        }\n    }\n\n    /**\n     * @dev Tool to verify that a low level call was successful, and revert if it wasn't, either by bubbling the\n     * revert reason or using the provided one.\n     *\n     * _Available since v4.3._\n     */\n    function verifyCallResult(\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal pure returns (bytes memory) {\n        if (success) {\n            return returndata;\n        } else {\n            _revert(returndata, errorMessage);\n        }\n    }\n\n    function _revert(bytes memory returndata, string memory errorMessage) private pure {\n        // Look for revert reason and bubble it up if present\n        if (returndata.length > 0) {\n            // The easiest way to bubble the revert reason is using memory via assembly\n            /// @solidity memory-safe-assembly\n            assembly {\n                let returndata_size := mload(returndata)\n                revert(add(32, returndata), returndata_size)\n            }\n        } else {\n            revert(errorMessage);\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/Context.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/Context.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract Context {\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/StorageSlot.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (utils/StorageSlot.sol)\n// This file was procedurally generated from scripts/generate/templates/StorageSlot.js.\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Library for reading and writing primitive types to specific storage slots.\n *\n * Storage slots are often used to avoid storage conflict when dealing with upgradeable contracts.\n * This library helps with reading and writing to such slots without the need for inline assembly.\n *\n * The functions in this library return Slot structs that contain a `value` member that can be used to read or write.\n *\n * Example usage to set ERC1967 implementation slot:\n * ```solidity\n * contract ERC1967 {\n *     bytes32 internal constant _IMPLEMENTATION_SLOT = 0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc;\n *\n *     function _getImplementation() internal view returns (address) {\n *         return StorageSlot.getAddressSlot(_IMPLEMENTATION_SLOT).value;\n *     }\n *\n *     function _setImplementation(address newImplementation) internal {\n *         require(Address.isContract(newImplementation), \"ERC1967: new implementation is not a contract\");\n *         StorageSlot.getAddressSlot(_IMPLEMENTATION_SLOT).value = newImplementation;\n *     }\n * }\n * ```\n *\n * _Available since v4.1 for `address`, `bool`, `bytes32`, `uint256`._\n * _Available since v4.9 for `string`, `bytes`._\n */\nlibrary StorageSlot {\n    struct AddressSlot {\n        address value;\n    }\n\n    struct BooleanSlot {\n        bool value;\n    }\n\n    struct Bytes32Slot {\n        bytes32 value;\n    }\n\n    struct Uint256Slot {\n        uint256 value;\n    }\n\n    struct StringSlot {\n        string value;\n    }\n\n    struct BytesSlot {\n        bytes value;\n    }\n\n    /**\n     * @dev Returns an `AddressSlot` with member `value` located at `slot`.\n     */\n    function getAddressSlot(bytes32 slot) internal pure returns (AddressSlot storage r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            r.slot := slot\n        }\n    }\n\n    /**\n     * @dev Returns an `BooleanSlot` with member `value` located at `slot`.\n     */\n    function getBooleanSlot(bytes32 slot) internal pure returns (BooleanSlot storage r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            r.slot := slot\n        }\n    }\n\n    /**\n     * @dev Returns an `Bytes32Slot` with member `value` located at `slot`.\n     */\n    function getBytes32Slot(bytes32 slot) internal pure returns (Bytes32Slot storage r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            r.slot := slot\n        }\n    }\n\n    /**\n     * @dev Returns an `Uint256Slot` with member `value` located at `slot`.\n     */\n    function getUint256Slot(bytes32 slot) internal pure returns (Uint256Slot storage r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            r.slot := slot\n        }\n    }\n\n    /**\n     * @dev Returns an `StringSlot` with member `value` located at `slot`.\n     */\n    function getStringSlot(bytes32 slot) internal pure returns (StringSlot storage r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            r.slot := slot\n        }\n    }\n\n    /**\n     * @dev Returns an `StringSlot` representation of the string storage pointer `store`.\n     */\n    function getStringSlot(string storage store) internal pure returns (StringSlot storage r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            r.slot := store.slot\n        }\n    }\n\n    /**\n     * @dev Returns an `BytesSlot` with member `value` located at `slot`.\n     */\n    function getBytesSlot(bytes32 slot) internal pure returns (BytesSlot storage r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            r.slot := slot\n        }\n    }\n\n    /**\n     * @dev Returns an `BytesSlot` representation of the bytes storage pointer `store`.\n     */\n    function getBytesSlot(bytes storage store) internal pure returns (BytesSlot storage r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            r.slot := store.slot\n        }\n    }\n}\n"
    },
    "contracts/ETSRelayerFactory.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\n/**\n * @title ETS Relayer Factory\n * @author Ethereum Tag Service <team@ets.xyz>\n *\n *  \n *  \n *          \n *          \n *        \n *        \n *\n * @notice Factory contract for deploying upgradeable beacon proxy contract instances.\n * @dev see ETSRelayerBeacon.sol & ETSRelayerV1.sol\n */\n\npragma solidity ^0.8.10;\n\nimport { IETS } from \"./interfaces/IETS.sol\";\nimport { IETSTarget } from \"./interfaces/IETSTarget.sol\";\nimport { IETSToken } from \"./interfaces/IETSToken.sol\";\nimport { IETSAccessControls } from \"./interfaces/IETSAccessControls.sol\";\nimport { ETSRelayerBeacon } from \"./relayers/ETSRelayerBeacon.sol\";\nimport { ETSRelayerV1 } from \"./relayers/ETSRelayerV1.sol\";\n\nimport { Context } from \"@openzeppelin/contracts/utils/Context.sol\";\nimport { BeaconProxy } from \"@openzeppelin/contracts/proxy/beacon/BeaconProxy.sol\";\n\ncontract ETSRelayerFactory is Context {\n    mapping(uint256 => address) private vaults;\n\n    ETSRelayerBeacon immutable etsRelayerBeacon;\n\n    /// @dev ETS access controls contract.\n    IETSAccessControls public etsAccessControls;\n\n    /// @dev Address and interface for ETS Core.\n    IETS public ets;\n\n    /// @dev Address and interface for ETS Token\n    IETSToken public etsToken;\n\n    /// @dev Address and interface for ETS Target.\n    IETSTarget public etsTarget;\n\n    // Modifiers\n\n    modifier onlyValidName(string calldata _name) {\n        require(!etsAccessControls.isRelayerByName(_name), \"Relayer name exists\");\n        bytes memory nameBytes = bytes(_name);\n        require(nameBytes.length >= 2, \"Relayer name too short\");\n        require(nameBytes.length <= 32, \"Relayer name too long\");\n        _;\n    }\n\n    /// Public constants\n\n    string public constant NAME = \"ETS Relayer Factory V1\";\n\n    constructor(\n        address _etsRelayerLogic,\n        IETSAccessControls _etsAccessControls,\n        IETS _ets,\n        IETSToken _etsToken,\n        IETSTarget _etsTarget\n    ) {\n        etsRelayerBeacon = new ETSRelayerBeacon(_etsRelayerLogic);\n        etsAccessControls = _etsAccessControls;\n        ets = _ets;\n        etsToken = _etsToken;\n        etsTarget = _etsTarget;\n    }\n\n    function addRelayer(string calldata _relayerName) external onlyValidName(_relayerName) returns (address relayer) {\n        if (!etsAccessControls.isRelayerAdmin(_msgSender())) {\n            require(etsToken.balanceOf(_msgSender()) > 0,\"Must own CTAG\");\n            require(!etsAccessControls.isRelayerByOwner(_msgSender()), \"Sender owns relayer\");\n        }\n\n        BeaconProxy relayerProxy = new BeaconProxy(\n            address(etsRelayerBeacon),\n            abi.encodeWithSelector(\n                ETSRelayerV1(payable(address(0))).initialize.selector,\n                _relayerName,\n                ets,\n                etsToken,\n                etsTarget,\n                etsAccessControls,\n                payable(_msgSender()),\n                payable(_msgSender())\n            )\n        );\n\n        etsAccessControls.registerRelayer(address(relayerProxy), _relayerName, _msgSender());\n        return address(relayerProxy);\n    }\n\n    function getImplementation() public view returns (address) {\n        return etsRelayerBeacon.implementation();\n    }\n\n    function getBeacon() public view returns (address) {\n        return address(etsRelayerBeacon);\n    }\n}\n"
    },
    "contracts/interfaces/IETS.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\n/**\n * @title IETS\n * @author Ethereum Tag Service <team@ets.xyz>\n *\n *  \n *  \n *          \n *          \n *        `\n *        \n *\n * @notice This is the interface for the ETS.sol core contract that records ETS TaggingRecords to the blockchain.\n */\n\npragma solidity ^0.8.10;\n\ninterface IETS {\n    /**\n     * @notice Data structure for raw client input data.\n     *\n     * @param targetURI Unique resource identifier string, eg. \"https://google.com\"\n     * @param tagStrings Array of hashtag strings, eg. [\"#Love, \"#Blue\"]\n     * @param recordType Arbitrary identifier for type of tagging record, eg. \"Bookmark\"\n     */\n    struct TaggingRecordRawInput {\n        string targetURI;\n        string[] tagStrings;\n        string recordType;\n    }\n\n    /**\n     * @notice Data structure for an Ethereum Tag Service \"tagging record\".\n     *\n     * The TaggingRecord is the fundamental data structure of ETS and reflects \"who tagged what, where and why\".\n     *\n     * Every Tagging record has a unique Id computed from the hashed composite of targetId, recordType, tagger and\n     * relayer addresses cast as a uint256. see computeTaggingRecordId()\n     *\n     * Given this design, a tagger who tags the same URI with the same tags and recordType via two different relayers\n     * would produce two TaggingRecords in ETS.\n     *\n     * @param tagIds Ids of CTAG token(s).\n     * @param targetId Id of target being tagged.\n     * @param recordType Arbitrary identifier for type of tagging record.\n     * @param relayer Address of Relayer contract that wrote tagging record.\n     * @param tagger Address of wallet that initiated tagging record via relayer.\n     */\n    struct TaggingRecord {\n        uint256[] tagIds;\n        uint256 targetId;\n        string recordType;\n        address relayer;\n        address tagger;\n    }\n\n    /**\n     * @dev Action types available for tags in a tagging record.\n     *\n     * 0 - APPEND Add tags to a tagging record.\n     * 1 - REPLACE Replace (overwrite) tags in a tagging record.\n     * 2 - REMOVE Remove tags in a tagging record.\n     */\n    enum TaggingAction {\n        APPEND,\n        REPLACE,\n        REMOVE\n    }\n\n    /**\n     * @dev emitted when the ETS Access Controls is set.\n     *\n     * @param newAccessControls contract address access controls is set to.\n     */\n    event AccessControlsSet(address newAccessControls);\n\n    /**\n     * @dev emitted when ETS tagging fee is set.\n     *\n     * @param newTaggingFee new tagging fee.\n     */\n    event TaggingFeeSet(uint256 newTaggingFee);\n\n    /**\n     * @dev emitted when participant distribution percentages are set.\n     *\n     * @param platformPercentage percentage of tagging fee allocated to ETS.\n     * @param relayerPercentage percentage of tagging fee allocated to relayer of record for CTAG being used in tagging record.\n     */\n    event PercentagesSet(uint256 platformPercentage, uint256 relayerPercentage);\n\n    /**\n     * @dev emitted when a new tagging record is recorded within ETS.\n     *\n     * @param taggingRecordId Unique identifier of tagging record.\n     */\n    event TaggingRecordCreated(uint256 taggingRecordId);\n\n    /**\n     * @dev emitted when a tagging record is updated.\n     *\n     * @param taggingRecordId tagging record being updated.\n     * @param action Type of update applied as TaggingAction enum.\n     */\n    event TaggingRecordUpdated(uint256 taggingRecordId, TaggingAction action);\n\n    /**\n     * @dev emitted when ETS participant draws down funds accrued to their contract or wallet.\n     *\n     * @param who contract or wallet address being drawn down.\n     * @param amount amount being drawn down.\n     */\n    event FundsWithdrawn(address indexed who, uint256 amount);\n\n    // ============ PUBLIC INTERFACE ============\n\n    /**\n     * @notice Create a new tagging record.\n     *\n     * Requirements:\n     *\n     *   - Caller must be relayer contract.\n     *   - CTAG(s) and TargetId must exist.\n     *\n     * @param _tagIds Array of CTAG token Ids.\n     * @param _targetId targetId of the URI being tagged. See ETSTarget.sol\n     * @param _recordType Arbitrary identifier for type of tagging record.\n     * @param _tagger Address calling Relayer contract to create tagging record.\n     */\n    function createTaggingRecord(\n        uint256[] memory _tagIds,\n        uint256 _targetId,\n        string calldata _recordType,\n        address _tagger\n    ) external payable;\n\n    /**\n     * @notice Get or create CTAG token from tag string.\n     *\n     * Combo function that accepts a tag string and returns corresponding CTAG token Id if it exists,\n     * or if it doesn't exist, creates a new CTAG and then returns corresponding Id.\n     *\n     * Only ETS Relayer contracts may call this function.\n     *\n     * @param _tag Tag string.\n     * @param _creator Address credited with creating CTAG.\n     * @return tokenId Id of CTAG token.\n     */\n    function getOrCreateTagId(\n        string calldata _tag,\n        address payable _creator\n    ) external payable returns (uint256 tokenId);\n\n    /**\n     * @notice Create CTAG token from tag string.\n     *\n     * Reverts if tag exists or is invalid.\n     *\n     * Only ETS Relayer contracts may call this function.\n     *\n     * @param _tag Tag string.\n     * @param _creator Address credited with creating CTAG.\n     * @return tokenId Id of CTAG token.\n     */\n    function createTag(string calldata _tag, address payable _creator) external payable returns (uint256 tokenId);\n\n    /**\n     * @notice Apply one or more tags to a targetURI using tagging record raw client input data.\n     *\n     * Like it's sister function applyTagsWithCompositeKey, records new ETS Tagging Record or appends tags to an\n     * existing record if found to already exist. This function differs in that it creates new ETS target records\n     * and CTAG tokens for novel targetURIs and hastag strings respectively. This function can only be called by\n     * Relayer contracts.\n     *\n     * @param _rawInput Raw client input data formed as TaggingRecordRawInput struct.\n     * @param _tagger Address that calls Relayer to tag a targetURI.\n     */\n    function applyTagsWithRawInput(TaggingRecordRawInput calldata _rawInput, address payable _tagger) external payable;\n\n    /**\n     * @notice Apply one or more tags to a targetId using using tagging record composite key.\n     *\n     * Records new ETS Tagging Record to the blockchain or appends tags if Tagging Record already exists. CTAGs and\n     * targetId are created if they don't exist. Caller must be Relayer contract.\n     *\n     * @param _tagIds Array of CTAG token Ids.\n     * @param _targetId targetId of the URI being tagged. See ETSTarget.sol\n     * @param _recordType Arbitrary identifier for type of tagging record.\n     * @param _tagger Address of that calls Relayer to create tagging record.\n     */\n    function applyTagsWithCompositeKey(\n        uint256[] calldata _tagIds,\n        uint256 _targetId,\n        string memory _recordType,\n        address payable _tagger\n    ) external payable;\n\n    /**\n     * @notice Replace entire tag set in tagging record using raw data for record lookup.\n     *\n     * If supplied tag strings don't have CTAGs, new ones are minted.\n     *\n     * @param _rawInput Raw client input data formed as TaggingRecordRawInput struct.\n     * @param _tagger Address that calls Relayer to tag a targetURI.\n     */\n    function replaceTagsWithRawInput(\n        TaggingRecordRawInput calldata _rawInput,\n        address payable _tagger\n    ) external payable;\n\n    /**\n     * @notice Replace entire tag set in tagging record using composite key for record lookup.\n     *\n     * This function overwrites the tags in a tagging record with the supplied tags, only\n     * charging for the new tags in the replacement set.\n     *\n     * @param _tagIds Array of CTAG token Ids.\n     * @param _targetId targetId of the URI being tagged. See ETSTarget.sol\n     * @param _recordType Arbitrary identifier for type of tagging record.\n     * @param _tagger Address of that calls Relayer to create tagging record.\n     */\n    function replaceTagsWithCompositeKey(\n        uint256[] calldata _tagIds,\n        uint256 _targetId,\n        string memory _recordType,\n        address payable _tagger\n    ) external payable;\n\n    /**\n     * @notice Remove one or more tags from a tagging record using raw data for record lookup.\n     *\n     * @param _rawInput Raw client input data formed as TaggingRecordRawInput struct.\n     * @param _tagger Address that calls Relayer to tag a targetURI.\n     */\n    function removeTagsWithRawInput(TaggingRecordRawInput calldata _rawInput, address _tagger) external;\n\n    /**\n     * @notice Remove one or more tags from a tagging record using composite key for record lookup.\n     *\n     * @param _tagIds Array of CTAG token Ids.\n     * @param _targetId targetId of the URI being tagged. See ETSTarget.sol\n     * @param _recordType Arbitrary identifier for type of tagging record.\n     * @param _tagger Address of that calls Relayer to create tagging record.\n     */\n    function removeTagsWithCompositeKey(\n        uint256[] calldata _tagIds,\n        uint256 _targetId,\n        string memory _recordType,\n        address payable _tagger\n    ) external;\n\n    /**\n     * @notice Append one or more tags to a tagging record.\n     *\n     * @param _taggingRecordId tagging record being updated.\n     * @param _tagIds Array of CTAG token Ids.\n     */\n    function appendTags(uint256 _taggingRecordId, uint256[] calldata _tagIds) external payable;\n\n    /**\n     * @notice Replaces tags in tagging record.\n     *\n     * This function overwrites the tags in a tagging record with the supplied tags, only\n     * charging for the new tags in the replacement set.\n     *\n     * @param _taggingRecordId tagging record being updated.\n     * @param _tagIds Array of CTAG token Ids.\n     */\n    function replaceTags(uint256 _taggingRecordId, uint256[] calldata _tagIds) external payable;\n\n    /**\n     * @notice Remove one or more tags from a tagging record.\n     *\n     * @param _taggingRecordId tagging record being updated.\n     * @param _tagIds Array of CTAG token Ids.\n     */\n    function removeTags(uint256 _taggingRecordId, uint256[] calldata _tagIds) external;\n\n    /**\n     * @notice Function for withdrawing funds from an accrual account. Can be called by the account owner\n     * or on behalf of the account. Does nothing when there is nothing due to the account.\n     *\n     * @param _account Address of account being drawn down and which will receive the funds.\n     */\n    function drawDown(address payable _account) external;\n\n    // ============ PUBLIC VIEW FUNCTIONS ============\n\n    /**\n     * @notice Compute a taggingRecordId from raw input.\n     *\n     * @param _rawInput Raw client input data formed as TaggingRecordRawInput struct.\n     * @param _relayer Address of tagging record Relayer contract.\n     * @param _tagger Address interacting with Relayer to tag content (\"Tagger\").\n     *\n     * @return taggingRecordId Unique identifier for a tagging record.\n     */\n    function computeTaggingRecordIdFromRawInput(\n        TaggingRecordRawInput calldata _rawInput,\n        address _relayer,\n        address _tagger\n    ) external view returns (uint256 taggingRecordId);\n\n    /**\n     * @notice Compute & return a taggingRecordId.\n     *\n     * Every TaggingRecord in ETS is mapped to by it's taggingRecordId. This Id is a composite key\n     * composed of targetId, recordType, relayer contract address and tagger address hashed and cast as a uint256.\n     *\n     * @param _targetId Id of target being tagged (see ETSTarget.sol).\n     * @param _recordType Arbitrary identifier for type of tagging record.\n     * @param _relayer Address of tagging record Relayer contract.\n     * @param _tagger Address interacting with Relayer to tag content (\"Tagger\").\n     *\n     * @return taggingRecordId Unique identifier for a tagging record.\n     */\n    function computeTaggingRecordIdFromCompositeKey(\n        uint256 _targetId,\n        string memory _recordType,\n        address _relayer,\n        address _tagger\n    ) external pure returns (uint256 taggingRecordId);\n\n    /**\n     * @notice Compute tagging fee for raw input and desired action.\n     *\n     * @param _rawInput Raw client input data formed as TaggingRecordRawInput struct.\n     * @param _relayer Address of tagging record Relayer contract.\n     * @param _tagger Address interacting with Relayer to tag content (\"Tagger\").\n     * @param _action Integer representing action to be performed according to enum TaggingAction.\n     *\n     * @return fee Calculated tagging fee in ETH/Matic\n     * @return tagCount Number of new tags being added to tagging record.\n     */\n    function computeTaggingFeeFromRawInput(\n        TaggingRecordRawInput memory _rawInput,\n        address _relayer,\n        address _tagger,\n        TaggingAction _action\n    ) external view returns (uint256 fee, uint256 tagCount);\n\n    /**\n     * @notice Compute tagging fee for CTAGs, tagging record composite key and desired action.\n     *\n     * @param _tagIds Array of CTAG token Ids.\n     * @param _relayer Address of tagging record Relayer contract.\n     * @param _tagger Address interacting with Relayer to tag content (\"Tagger\").\n     * @param _action Integer representing action to be performed according to enum TaggingAction.\n     *\n     * @return fee Calculated tagging fee in ETH/Matic\n     * @return tagCount Number of new tags being added to tagging record.\n     */\n    function computeTaggingFeeFromCompositeKey(\n        uint256[] memory _tagIds,\n        uint256 _targetId,\n        string calldata _recordType,\n        address _relayer,\n        address _tagger,\n        TaggingAction _action\n    ) external view returns (uint256 fee, uint256 tagCount);\n\n    /**\n     * @notice Compute tagging fee for CTAGs, tagging record id and desired action.\n     *\n     * If the global, service wide tagging fee is set (see ETS.taggingFee() & ETS.setTaggingFee()) ETS charges a per tag for all\n     * new tags applied to a tagging record. This applies to both new tagging records and modified tagging records.\n     *\n     * Computing the tagging fee involves checking to see if a tagging record exists and if so, given the desired action\n     * (append or replace) determining the number of new tags being added and multiplying by the ETS per tag fee.\n     *\n     * @param _taggingRecordId Id of tagging record.\n     * @param _tagIds Array of CTAG token Ids.\n     * @param _action Integer representing action to be performed according to enum TaggingAction.\n     *\n     * @return fee Calculated tagging fee in ETH/Matic\n     * @return tagCount Number of new tags being added to tagging record.\n     */\n    function computeTaggingFee(\n        uint256 _taggingRecordId,\n        uint256[] memory _tagIds,\n        TaggingAction _action\n    ) external view returns (uint256 fee, uint256 tagCount);\n\n    /**\n     * @notice Retrieve a tagging record from it's raw input.\n     *\n     * @param _rawInput Raw client input data formed as TaggingRecordRawInput struct.\n     * @param _relayer Address of tagging record Relayer contract.\n     * @param _tagger Address interacting with Relayer to tag content (\"Tagger\").\n     *\n     * @return tagIds CTAG token ids.\n     * @return targetId TargetId that was tagged.\n     * @return recordType Type of tagging record.\n     * @return relayer Address of tagging record Relayer contract.\n     * @return tagger Address interacting with Relayer to tag content (\"Tagger\").\n     */\n    function getTaggingRecordFromRawInput(\n        TaggingRecordRawInput memory _rawInput,\n        address _relayer,\n        address _tagger\n    )\n        external\n        view\n        returns (uint256[] memory tagIds, uint256 targetId, string memory recordType, address relayer, address tagger);\n\n    /**\n     * @notice Retrieve a tagging record from composite key parts.\n     *\n     * @param _targetId Id of target being tagged.\n     * @param _recordType Arbitrary identifier for type of tagging record.\n     * @param _relayer Address of Relayer contract that wrote tagging record.\n     * @param _tagger Address of wallet that initiated tagging record via relayer.\n     *\n     * @return tagIds CTAG token ids.\n     * @return targetId TargetId that was tagged.\n     * @return recordType Type of tagging record.\n     * @return relayer Address of tagging record Relayer contract.\n     * @return tagger Address interacting with Relayer to tag content (\"Tagger\").\n     */\n    function getTaggingRecordFromCompositeKey(\n        uint256 _targetId,\n        string memory _recordType,\n        address _relayer,\n        address _tagger\n    )\n        external\n        view\n        returns (uint256[] memory tagIds, uint256 targetId, string memory recordType, address relayer, address tagger);\n\n    /**\n     * @notice Retrieve a tagging record from Id.\n     *\n     * @param _id taggingRecordId.\n     *\n     * @return tagIds CTAG token ids.\n     * @return targetId TargetId that was tagged.\n     * @return recordType Type of tagging record.\n     * @return relayer Address of tagging record Relayer contract.\n     * @return tagger Address interacting with Relayer to tag content (\"Tagger\").\n     */\n    function getTaggingRecordFromId(\n        uint256 _id\n    )\n        external\n        view\n        returns (uint256[] memory tagIds, uint256 targetId, string memory recordType, address relayer, address tagger);\n\n    /**\n     * @notice Check that a tagging record exists for given raw input.\n     *\n     * @param _rawInput Raw client input data formed as TaggingRecordRawInput struct.\n     * @param _relayer Address of tagging record Relayer contract.\n     * @param _tagger Address interacting with Relayer to tag content (\"Tagger\").\n     *\n     * @return boolean; true for exists, false for not.\n     */\n    function taggingRecordExistsByRawInput(\n        TaggingRecordRawInput memory _rawInput,\n        address _relayer,\n        address _tagger\n    ) external view returns (bool);\n\n    /**\n     * @notice Check that a tagging record exists by it's componsite key parts.\n     *\n     * @param _targetId Id of target being tagged.\n     * @param _recordType Arbitrary identifier for type of tagging record.\n     * @param _relayer Address of Relayer contract that wrote tagging record.\n     * @param _tagger Address of wallet that initiated tagging record via relayer.\n     *\n     * @return boolean; true for exists, false for not.\n     */\n    function taggingRecordExistsByCompositeKey(\n        uint256 _targetId,\n        string memory _recordType,\n        address _relayer,\n        address _tagger\n    ) external view returns (bool);\n\n    /**\n     * @notice Check that a tagging record exsits by it's Id.\n     *\n     * @param _taggingRecordId taggingRecordId.\n     *\n     * @return boolean; true for exists, false for not.\n     */\n    function taggingRecordExists(uint256 _taggingRecordId) external view returns (bool);\n\n    /**\n     * @notice Function to check how much MATIC has been accrued by an address factoring in amount paid out.\n     *\n     * @param _account Address of the account being queried.\n     * @return _due Amount of WEI in MATIC due to account.\n     */\n    function totalDue(address _account) external view returns (uint256 _due);\n\n    /**\n     * @notice Function to retrieve the ETS platform tagging fee.\n     *\n     * @return tagging fee.\n     */\n    function taggingFee() external view returns (uint256);\n}\n"
    },
    "contracts/interfaces/IETSAccessControls.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\n/**\n * @title IETSAccessControls\n * @author Ethereum Tag Service <team@ets.xyz>\n *\n *  \n *  \n *          \n *          \n *        `\n *        \n *\n * @notice This is the interface for the ETSAccessControls contract which allows ETS Core Dev\n * Team to administer roles and control access to various parts of the ETS Platform.\n * ETSAccessControls contract contains a mix of public and administrator only functions.\n */\n\npragma solidity ^0.8.10;\n\nimport { IAccessControlUpgradeable } from \"@openzeppelin/contracts-upgradeable/access/IAccessControlUpgradeable.sol\";\n\ninterface IETSAccessControls is IAccessControlUpgradeable {\n    /**\n     * @dev emitted when the ETS Platform address is set.\n     *\n     * @param newAddress wallet address platform is being set to.\n     * @param prevAddress previous platform address.\n     */\n    event PlatformSet(address newAddress, address prevAddress);\n\n    /**\n     * @dev emitted when a Relayer contract is added & enabled in ETS.\n     *\n     * Relayer contracts are not required implement all ETS Core API functions. Therefore, to ease\n     * testing of ETS Core API fuinctions, ETS permits addition of ETS owned wallet addresses as Relayers.\n     *\n     * @param relayer Relayer contract address.\n     */\n    event RelayerAdded(address relayer);\n\n    /**\n     * @dev emitted when a Relayer contract is paused or unpaused.\n     *\n     * @param relayer Address that had pause toggled.\n     */\n    event RelayerLockToggled(address relayer);\n\n    /**\n     * @notice Sets the Platform wallet address. Can only be called by address with DEFAULT_ADMIN_ROLE.\n     *\n     * @param _platform The new Platform address to set.\n     */\n    function setPlatform(address payable _platform) external;\n\n    /**\n     * @notice Adds a Relayer contract to ETS. Can only be called by address\n     * with DEFAULT_ADMIN_ROLE.\n     *\n     * @param _relayer Address of the Relayer contract. Must conform to IETSRelayer.\n     * @param _name Human readable name of the Relayer.\n     * @param _owner Address of relayer owner.\n     */\n    function registerRelayer(address _relayer, string calldata _name, address _owner) external;\n\n    /**\n     * @notice Pause relayer given the relayer owner address. Callable by Platform only.\n     *\n     * @param _relayerOwner Address of the Relayer owner.\n     */\n    function pauseRelayerByOwnerAddress(address _relayerOwner) external;\n\n    /**\n     * @notice Change the relayer owner as stored in ETSAccessControls. Callable from Relayer only.\n     * Called via changeOwner() on a relayer.\n     *\n     * @param _currentOwner Address of the current relayer owner.\n     * @param _newOwner Address of the new relayer owner.\n     */\n    function changeRelayerOwner(address _currentOwner, address _newOwner) external;\n\n    /**\n     * @notice Pauses/Unpauses a Relayer contract. Can only be called by address\n     * with DEFAULT_ADMIN_ROLE.\n     *\n     * @param _relayer Address of the Relayer contract.\n     */\n    function toggleRelayerLock(address _relayer) external;\n\n    /**\n     * @notice Sets the role admin for a given role. An address with role admin can grant or\n     * revoke that role for other addresses. Can only be called by address with DEFAULT_ADMIN_ROLE.\n     *\n     * @param _role bytes32 representation of role being administered.\n     * @param _adminRole bytes32 representation of administering role.\n     */\n    function setRoleAdmin(bytes32 _role, bytes32 _adminRole) external;\n\n    /**\n     * @notice Checks whether given address has SMART_CONTRACT role.\n     *\n     * @param _addr Address being checked.\n     * @return boolean True if address has SMART_CONTRACT role.\n     */\n    function isSmartContract(address _addr) external view returns (bool);\n\n    /**\n     * @notice Checks whether given address has DEFAULT_ADMIN_ROLE role.\n     *\n     * @param _addr Address being checked.\n     * @return boolean True if address has DEFAULT_ADMIN_ROLE role.\n     */\n    function isAdmin(address _addr) external view returns (bool);\n\n    /**\n     * @notice Checks whether given address has AUCTION_ORACLE_ROLE role.\n     *\n     * @param _addr Address being checked.\n     * @return boolean True if address has AUCTION_ORACLE_ROLE role.\n     */\n    function isAuctionOracle(address _addr) external view returns (bool);\n\n    /**\n     * @notice Checks whether given address can act as relayer factory.\n     *\n     * @param _addr Address being checked.\n     * @return boolean True if address can act as relayer factory.\n     */\n    function isRelayerFactory(address _addr) external view returns (bool);\n\n    /**\n     * @notice Checks whether given address is a relayer.\n     *\n     * @param _addr Address being checked.\n     * @return boolean True if address can be a relayer.\n     */\n    function isRelayer(address _addr) external view returns (bool);\n\n    /**\n     * @notice Checks whether given address is a registered Relayer and not paused.\n     *\n     * @param _addr Address being checked.\n     * @return boolean True if address is a Relayer and not paused.\n     */\n    function isRelayerAndNotPaused(address _addr) external view returns (bool);\n\n    /**\n     * @notice Checks relayer is paused by ETS Platform.\n     *\n     * @param _addr Address being checked.\n     * @return boolean True if relayer address is paused by platform.\n     */\n    function isRelayerLocked(address _addr) external view returns (bool);\n\n    /**\n     * @notice Checks whether given address owns a relayer.\n     *\n     * @param _addr Address being checked.\n     * @return boolean True if address owns a relayer.\n     */\n    function isRelayerByOwner(address _addr) external view returns (bool);\n\n    /**\n     * @notice Checks whether given address has RELAYER_ADMIN role.\n     *\n     * @param _addr Address being checked.\n     * @return boolean True if address has RELAYER_ADMIN role.\n     */\n    function isRelayerAdmin(address _addr) external view returns (bool);\n\n    /**\n     * @notice Checks whether given Relayer Name is a registered Relayer.\n     *\n     * @param _name Name being checked.\n     * @return boolean True if _name is a Relayer.\n     */\n    function isRelayerByName(string calldata _name) external view returns (bool);\n\n    /**\n     * @notice Checks whether given address is a registered Relayer.\n     *\n     * @param _addr Address being checked.\n     * @return boolean True if address is a registered Relayer.\n     */\n    function isRelayerByAddress(address _addr) external view returns (bool);\n\n    /**\n     * @notice Get relayer address from it's name.\n     *\n     * @param _name Name of relayer.\n     * @return Address of relayer.\n     */\n    function getRelayerAddressFromName(string calldata _name) external view returns (address);\n\n    /**\n     * @notice Get relayer name from it's address.\n     *\n     * @param _address Adsdress of relayer.\n     * @return Name of relayer.\n     */\n    function getRelayerNameFromAddress(address _address) external view returns (string calldata);\n\n    /**\n     * @notice Get relayer address from its owner address.\n     *\n     * @param _address address of relayer owner.\n     * @return Address of relayer.\n     */\n    function getRelayerAddressFromOwner(address _address) external view returns (address);\n\n    /**\n     * @notice Returns wallet address for ETS Platform.\n     *\n     * @return ETS Platform address.\n     */\n    function getPlatformAddress() external view returns (address payable);\n}\n"
    },
    "contracts/interfaces/IETSTarget.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\n/**\n * @title IETSTarget\n * @author Ethereum Tag Service <team@ets.xyz>\n *\n *  \n *  \n *          \n *          \n *        `\n *        \n *\n * @notice This is the standard interface for the core ETSTarget.sol contract. It includes both public\n * and administration functions.\n *\n * In ETS, a \"Target\" is our data structure, stored onchain, that references/points to a URI. Target records\n * are identified in ETS by their Id (targetId) which is a unsigned integer computed from the URI string.\n * Target Ids are combined with CTAG Ids by ETS core (ETS.sol) to form \"Tagging Records\".\n *\n * For context, from Wikipedia, URI is short for Uniform Resource Identifier and is a unique sequence of\n * characters that identifies a logical or physical resource used by web technologies. URIs may be used to\n * identify anything, including real-world objects, such as people and places, concepts, or information\n * resources such as web pages and books.\n *\n * For our purposes, as much as possible, we are restricting our interpretation of URIs to the more technical\n * parameters defined by the IETF in [RFC3986](https://www.rfc-editor.org/rfc/rfc3986). For newer protocols, such\n * as blockchains, For newer protocols, such as blockchains we will lean on newer emerging URI standards such\n * as the [Blink](https://w3c-ccg.github.io/blockchain-links) and [BIP-122](https://github.com/bitcoin/bips/blob/master/bip-0122.mediawiki)\n *\n * One the thing to keep in mind with URIs & ETS Targets is that differently shaped URIs can sometimes point to the same\n * resource. The effect of that is that different Target IDs in ETS can similarly point to the same resource.\n */\n\npragma solidity ^0.8.10;\n\ninterface IETSTarget {\n    /**\n     * @notice Data structure for an ETS Target.\n     *\n     * @param targetURI Unique resource identifier Target points to\n     * @param createdBy Address of IETSTargetTagger implementation that created Target\n     * @param enriched block timestamp when Target was last enriched. Defaults to 0\n     * @param httpStatus https status of last response from ETSEnrichTarget API eg. \"404\", \"200\". defaults to 0\n     * @param ipfsHash ipfsHash of additional metadata for Target collected by ETSEnrichTarget API\n     */\n    struct Target {\n        string targetURI;\n        address createdBy;\n        uint256 enriched;\n        uint256 httpStatus;\n        string ipfsHash;\n    }\n\n    /**\n     * @dev emitted when the ETSAccessControls is set.\n     *\n     * @param etsAccessControls contract address ETSAccessControls is set to.\n     */\n    event AccessControlsSet(address etsAccessControls);\n\n    /**\n     * @dev emitted when the ETSEnrichTarget API address is set.\n     *\n     * @param etsEnrichTarget contract address ETSEnrichTarget is set to.\n     */\n    event EnrichTargetSet(address etsEnrichTarget);\n\n    /**\n     * @dev emitted when a new Target is created.\n     *\n     * @param targetId Unique Id of new Target.\n     */\n    event TargetCreated(uint256 targetId);\n\n    /**\n     * @dev emitted when an existing Target is updated.\n     *\n     * @param targetId Id of Target being updated.\n     */\n    event TargetUpdated(uint256 targetId);\n\n    /**\n     * @notice Sets ETSEnrichTarget contract address so that Target metadata enrichment\n     * functions can be called from ETSTarget.\n     *\n     * @param _etsEnrichTarget Address of ETSEnrichTarget contract.\n     */\n    function setEnrichTarget(address _etsEnrichTarget) external;\n\n    /**\n     * @notice Get ETS targetId from URI.\n     *\n     * Combo function that given a URI string will return it's ETS targetId if it exists,\n     * or create a new Target record and return corresponding targetId.\n     *\n     * @param _targetURI URI passed in as string\n     * @return Id of ETS Target record\n     */\n    function getOrCreateTargetId(string memory _targetURI) external returns (uint256);\n\n    /**\n     * @notice Create a Target record and return it's targetId.\n     *\n     * @param _targetURI URI passed in as string\n     * @return targetId Id of ETS Target record\n     */\n    function createTarget(string memory _targetURI) external returns (uint256 targetId);\n\n    /**\n     * @notice Update a Target record.\n     *\n     * @param _targetId Id of Target being updated.\n     * @param _targetURI Unique resource identifier Target points to.\n     * @param _enriched block timestamp when Target was last enriched\n     * @param _httpStatus https status of last response from ETSEnrichTarget API eg. \"404\", \"200\". defaults to 0\n     * @param _ipfsHash ipfsHash of additional metadata for Target collected by ETSEnrichTarget API\n\n     * @return success true when Target is successfully updated.\n     */\n    function updateTarget(\n        uint256 _targetId,\n        string calldata _targetURI,\n        uint256 _enriched,\n        uint256 _httpStatus,\n        string calldata _ipfsHash\n    ) external returns (bool success);\n\n    /**\n     * @notice Function to deterministically compute & return a targetId.\n     *\n     * Every Target in ETS is mapped to by it's targetId. This Id is computed from\n     * the target URI sting hashed and cast as a uint256.\n     *\n     * Note: Function does not verify if Target record exists.\n     *\n     * @param _targetURI Unique resource identifier Target record points to.\n     * @return targetId Id of the potential Target record.\n     */\n    function computeTargetId(string memory _targetURI) external view returns (uint256 targetId);\n\n    /**\n     * @notice Check that a Target record exists for a given URI string.\n     *\n     * @param _targetURI Unique resource identifier Target record points to.\n     * @return true if Target record exists; false if not.\n     */\n    function targetExistsByURI(string memory _targetURI) external view returns (bool);\n\n    /**\n     * @notice Check that a Target record exists for a given computed targetId.\n     *\n     * @param _targetId targetId uint computed from URI via computeTargetId().\n     * @return true if Target record exists; false if not.\n     */\n    function targetExistsById(uint256 _targetId) external view returns (bool);\n\n    /**\n     * @notice Retrieve a Target record for a given URI string.\n     *\n     * Note: returns a struct with empty members when no Target exists.\n     *\n     * @param _targetURI Unique resource identifier Target record points to.\n     * @return Target record.\n     */\n    function getTargetByURI(string memory _targetURI) external view returns (Target memory);\n\n    /**\n     * @notice Retrieve a Target record for a computed targetId.\n     *\n     * Note: returns a struct with empty members when no Target exists.\n     *\n     * @param _targetId targetId uint computed from URI via computeTargetId().\n     * @return Target record.\n     */\n    function getTargetById(uint256 _targetId) external view returns (Target memory);\n}\n"
    },
    "contracts/interfaces/IETSToken.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\n/**\n * @title IETSToken\n * @author Ethereum Tag Service <team@ets.xyz>\n *\n *  \n *  \n *          \n *          \n *        `\n *        \n *\n * @notice This is the interface for the ETSToken.sol core contract that governs the creation & management\n * of Ethereum Tag Service composable tags (CTAGs).\n *\n * CTAGs are ERC-721 non-fungible tokens that store a single tag string and origin attribution data including\n * a \"Relayer\" address and a \"Creator\" address. The tag string must conform to a few simple validation rules.\n *\n * CTAGs are identified in ETS by their Id (tagId) which is an unsigned integer computed from the lowercased\n * tag \"display\" string. Given this, only one CTAG exists for a tag string regardless of its case. For\n * example, #Punks, #punks and #PUNKS all resolve to the same CTAG.\n *\n * CTAG Ids are combined with Target Ids (see ETSTarget.sol) by ETS core (ETS.sol) to form \"Tagging Records\".\n *\n * CTAGs may only be generated by Relayer contracts (see examples/ETSRelayer.sol) via ETS core (ETS.sol)\n */\n\npragma solidity ^0.8.10;\n\nimport { IERC721Upgradeable } from \"@openzeppelin/contracts-upgradeable/token/ERC721/IERC721Upgradeable.sol\";\n\ninterface IETSToken is IERC721Upgradeable {\n    /**\n     * @notice Data structure for CTAG Token.\n     *\n     * Only premium and reserved flags are editable.\n     *\n     * @param relayer Address of IETSTargetTagger implementation that created CTAG.\n     * @param creator Address interacting with relayer to initiate CTAG creation.\n     * @param display Display version of CTAG string.\n     * @param premium ETS governed boolean flag to identify a CTAG as premium/higher value.\n     * @param reserved ETS governed boolean flag to restrict a CTAG from release to auction.\n     */\n    struct Tag {\n        address relayer;\n        address creator;\n        string display;\n        bool premium;\n        bool reserved;\n    }\n\n    // Events\n\n    /**\n     * @dev emitted when the maximum character length of CTAG display string is set.\n     *\n     * @param maxStringLength maximum character length of string.\n     */\n    event TagMaxStringLengthSet(uint256 maxStringLength);\n\n    /**\n     * @dev emitted when the minimum character length of CTAG display string is set.\n     *\n     * @param minStringLength minimum character length of string.\n     */\n    event TagMinStringLengthSet(uint256 minStringLength);\n\n    /**\n     * @dev emitted when the ownership term length of a CTAG is set.\n     *\n     * @param termLength Ownership term length in days.\n     */\n    event OwnershipTermLengthSet(uint256 termLength);\n\n    /**\n     * @dev emitted when the ETS core contract is set.\n     *\n     * @param ets ets core contract address.\n     */\n    event ETSCoreSet(address ets);\n\n    /**\n     * @dev emitted when the ETS Access Controls is set.\n     *\n     * @param etsAccessControls contract address access controls is set to.\n     */\n    event AccessControlsSet(address etsAccessControls);\n\n    /**\n     * @dev emitted when a tag string is flagged/unflagged as premium prior to minting.\n     *\n     * @param tag tag string being flagged.\n     * @param isPremium boolean true for premium/false not premium.\n     */\n    event PremiumTagPreSet(string tag, bool isPremium);\n\n    /**\n     * @dev emitted when a CTAG is flagged/unflagged as premium subsequent to minting.\n     *\n     * @param tagId Id of CTAG token.\n     * @param isPremium boolean true for premium/false not premium.\n     */\n    event PremiumFlagSet(uint256 tagId, bool isPremium);\n\n    /**\n     * @dev emitted when a CTAG is flagged/unflagged as reserved subsequent to minting.\n     *\n     * @param tagId Id of CTAG token.\n     * @param isReserved boolean true for reserved/false for not reserved.\n     */\n    event ReservedFlagSet(uint256 tagId, bool isReserved);\n\n    /**\n     * @dev emitted when CTAG token is renewed.\n     *\n     * @param tokenId Id of CTAG token.\n     * @param caller address of renewer.\n     */\n    event TagRenewed(uint256 indexed tokenId, address indexed caller);\n\n    /**\n     * @dev emitted when CTAG token is recycled back to ETS.\n     *\n     * @param tokenId Id of CTAG token.\n     * @param caller address of recycler.\n     */\n    event TagRecycled(uint256 indexed tokenId, address indexed caller);\n\n    // ============ OWNER INTERFACE ============\n\n    /**\n     * @notice admin function to set maximum character length of CTAG display string.\n     *\n     * @param _tagMaxStringLength maximum character length of string.\n     */\n    function setTagMaxStringLength(uint256 _tagMaxStringLength) external;\n\n    /**\n     * @notice Admin function to set minimum  character length of CTAG display string.\n     *\n     * @param _tagMinStringLength minimum character length of string.\n     */\n    function setTagMinStringLength(uint256 _tagMinStringLength) external;\n\n    /**\n     * @notice Admin function to set the ownership term length of a CTAG is set.\n     *\n     * @param _ownershipTermLength Ownership term length in days.\n     */\n    function setOwnershipTermLength(uint256 _ownershipTermLength) external;\n\n    /**\n     * @notice Admin function to flag/unflag tag string(s) as premium prior to minting.\n     *\n     * @param _tags Array of tag strings.\n     * @param _isPremium Boolean true for premium, false for not premium.\n     */\n    function preSetPremiumTags(string[] calldata _tags, bool _isPremium) external;\n\n    /**\n     * @notice Admin function to flag/unflag CTAG(s) as premium.\n     *\n     * @param _tokenIds Array of CTAG Ids.\n     * @param _isPremium Boolean true for premium, false for not premium.\n     */\n    function setPremiumFlag(uint256[] calldata _tokenIds, bool _isPremium) external;\n\n    /**\n     * @notice Admin function to flag/unflag CTAG(s) as reserved.\n     *\n     * Tags flagged as reserved cannot be auctioned.\n     *\n     * @param _tokenIds Array of CTAG Ids.\n     * @param _reserved Boolean true for reserved, false for not reserved.\n     */\n    function setReservedFlag(uint256[] calldata _tokenIds, bool _reserved) external;\n\n    // ============ PUBLIC INTERFACE ============\n\n    /**\n     * @notice Get CTAG token Id from tag string.\n     *\n     * Combo function that accepts a tag string and returns it's CTAG token Id if it exists,\n     * or creates a new CTAG and returns corresponding Id.\n     *\n     * Only ETS Core can call this function.\n     *\n     * @param _tag Tag string.\n     * @param _relayer Address of Relayer contract calling ETS Core.\n     * @param _creator Address credited with creating CTAG.\n     * @return tokenId Id of CTAG token.\n     */\n    function getOrCreateTagId(\n        string calldata _tag,\n        address payable _relayer,\n        address payable _creator\n    ) external payable returns (uint256 tokenId);\n\n    /**\n     * @notice Create CTAG token from tag string.\n     *\n     * Reverts if tag exists or is invalid.\n     *\n     * Only ETS Core can call this function.\n     *\n     * @param _tag Tag string.\n     * @param _creator Address credited with creating CTAG.\n     * @return tokenId Id of CTAG token.\n     */\n    function createTag(\n        string calldata _tag,\n        address payable _relayer,\n        address payable _creator\n    ) external payable returns (uint256 tokenId);\n\n    /**\n     * @notice Renews ownership term of a CTAG.\n     *\n     * A \"CTAG ownership term\" is utilized to prevent CTAGs from being abandoned or inaccessable\n     * due to lost private keys.\n     *\n     * Any wallet address may renew the term of a CTAG for an owner. When renewed, the term\n     * is extended from the current block timestamp plus the ownershipTermLength public variable.\n     *\n     * @param _tokenId Id of CTAG token.\n     */\n    function renewTag(uint256 _tokenId) external;\n\n    /**\n     * @notice Recycles a CTAG back to ETS.\n     *\n     * When ownership term of a CTAG has expired, any wallet or contract may call this function\n     * to recycle the tag back to ETS. Once recycled, a tag may be auctioned again.\n     *\n     * @param _tokenId Id of CTAG token.\n     */\n    function recycleTag(uint256 _tokenId) external;\n\n    // ============ PUBLIC VIEW FUNCTIONS ============\n\n    /**\n     * @notice Function to deterministically compute & return a CTAG token Id.\n     *\n     * Every CTAG token and it's associated data struct is mapped to by it's token Id. This Id is computed\n     * from the \"display\" tag string lowercased, hashed and cast as an unsigned integer.\n     *\n     * Note: Function does not verify if CTAG record exists.\n     *\n     * @param _tag Tag string.\n     * @return Id of potential CTAG token id.\n     */\n    function computeTagId(string memory _tag) external pure returns (uint256);\n\n    /**\n     * @notice Check that a CTAG token exists for a given tag string.\n     *\n     * @param _tag Tag string.\n     * @return true if CTAG token exists; false if not.\n     */\n    function tagExistsByString(string calldata _tag) external view returns (bool);\n\n    /**\n     * @notice Check that CTAG token exists for a given computed token Id.\n     *\n     * @param _tokenId Token Id uint computed from tag string via computeTargetId().\n     * @return true if CTAG token exists; false if not.\n     */\n    function tagExistsById(uint256 _tokenId) external view returns (bool);\n\n    /**\n     * @notice Check if CTAG token ownership term has expired.\n     *\n     * @param _tokenId Token Id uint computed from tag string via computeTargetId().\n     * @return true if CTAG ownership term has expired; false if not.\n     */\n    function tagOwnershipTermExpired(uint256 _tokenId) external view returns (bool);\n\n    /**\n     * @notice Retrieve a CTAG record for a given tag string.\n     *\n     * Note: returns a struct with empty members when no CTAG exists.\n     *\n     * @param _tag Tag string.\n     * @return CTAG record as Tag struct.\n     */\n    function getTagByString(string calldata _tag) external view returns (Tag memory);\n\n    /**\n     * @notice Retrieve a CTAG record for a given token Id.\n     *\n     * Note: returns a struct with empty members when no CTAG exists.\n     *\n     * @param _tokenId CTAG token Id.\n     * @return CTAG record as Tag struct.\n     */\n    function getTagById(uint256 _tokenId) external view returns (Tag memory);\n\n    /**\n     * @notice Retrieve wallet address for ETS Platform.\n     *\n     * @return wallet address for ETS Platform.\n     */\n    function getPlatformAddress() external view returns (address payable);\n\n    /**\n     * @notice Retrieve Creator address for a CTAG token.\n     *\n     * @param _tokenId CTAG token Id.\n     * @return _creator Creator address of the CTAG.\n     */\n    function getCreatorAddress(uint256 _tokenId) external view returns (address);\n\n    /**\n     * @notice Retrieve last renewal block timestamp for a CTAG.\n     *\n     * @param _tokenId CTAG token Id.\n     * @return Block timestamp.\n     */\n    function getLastRenewed(uint256 _tokenId) external view returns (uint256);\n\n    /**\n     * @notice Retrieve CTAG ownership term length global setting.\n     *\n     * @return Term length in days.\n     */\n    function getOwnershipTermLength() external view returns (uint256);\n}\n"
    },
    "contracts/libraries/UintArrayUtils.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.10;\n\n// Adapted from Cryptofin labs Array Utilities\n// https://github.com/cryptofinlabs/cryptofin-solidity/blob/master/contracts/array-utils/AddressArrayUtils.sol\n\nlibrary UintArrayUtils {\n    /**\n     * Finds the index of the first occurrence of the given element.\n     * @param A The input array to search\n     * @param a The value to find\n     * @return Returns (index and isIn) for the first occurrence starting from index 0\n     */\n    function indexOf(uint256[] memory A, uint256 a) internal pure returns (uint256, bool) {\n        uint256 length = A.length;\n        for (uint256 i = 0; i < length; i++) {\n            if (A[i] == a) {\n                return (i, true);\n            }\n        }\n        return (0, false);\n    }\n\n    /**\n     * Returns true if the value is present in the list. Uses indexOf internally.\n     * @param A The input array to search\n     * @param a The value to find\n     * @return Returns isIn for the first occurrence starting from index 0\n     */\n    function contains(uint256[] memory A, uint256 a) internal pure returns (bool) {\n        (, bool isIn) = indexOf(A, a);\n        return isIn;\n    }\n\n    /**\n     * Computes the difference of two arrays. Assumes there are no duplicates.\n     * @param A The first array\n     * @param B The second array\n     * @return A - B; an array of values in A not found in B.\n     */\n    function difference(uint256[] memory A, uint256[] memory B) internal pure returns (uint256[] memory) {\n        uint256 length = A.length;\n        bool[] memory includeMap = new bool[](length);\n        uint256 count = 0;\n        // First count the new length because can't push for in-memory arrays\n        for (uint256 i = 0; i < length; i++) {\n            uint256 e = A[i];\n            if (!contains(B, e)) {\n                includeMap[i] = true;\n                count++;\n            }\n        }\n        uint256[] memory newItems = new uint256[](count);\n        uint256 j = 0;\n        for (uint256 i = 0; i < length; i++) {\n            if (includeMap[i]) {\n                newItems[j] = A[i];\n                j++;\n            }\n        }\n        return newItems;\n    }\n\n    /**\n     * Returns the intersection of two arrays. Arrays are treated as collections, so duplicates are kept.\n     * @param A The first array\n     * @param B The second array\n     * @return The intersection of the two arrays\n     */\n    function intersect(uint256[] memory A, uint256[] memory B) internal pure returns (uint256[] memory) {\n        uint256 length = A.length;\n        bool[] memory includeMap = new bool[](length);\n        uint256 newLength = 0;\n        for (uint256 i = 0; i < length; i++) {\n            if (contains(B, A[i])) {\n                includeMap[i] = true;\n                newLength++;\n            }\n        }\n        uint256[] memory newArray = new uint256[](newLength);\n        uint256 j = 0;\n        for (uint256 i = 0; i < length; i++) {\n            if (includeMap[i]) {\n                newArray[j] = A[i];\n                j++;\n            }\n        }\n        return newArray;\n    }\n\n    /**\n     * Returns the combination of two arrays\n     * @param A The first array\n     * @param B The second array\n     * @return Returns A extended by B\n     */\n    function extend(uint256[] memory A, uint256[] memory B) internal pure returns (uint256[] memory) {\n        uint256 aLength = A.length;\n        uint256 bLength = B.length;\n        uint256[] memory newArray = new uint256[](aLength + bLength);\n        for (uint256 i = 0; i < aLength; i++) {\n            newArray[i] = A[i];\n        }\n        for (uint256 i = 0; i < bLength; i++) {\n            newArray[aLength + i] = B[i];\n        }\n        return newArray;\n    }\n}\n"
    },
    "contracts/relayers/ETSRelayerBeacon.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\n/**\n * @title ETS Relayer Upgradeable Beacon\n * @author Ethereum Tag Service <team@ets.xyz>\n *\n *  \n *  \n *          \n *          \n *        \n *        \n *\n * @notice Upgradeable beacon proxy contract for upgrading the ETS Relayer proxies\n * deployed by ETSRelayerFactory.sol\n */\n\npragma solidity ^0.8.10;\n\nimport { UpgradeableBeacon } from \"@openzeppelin/contracts/proxy/beacon/UpgradeableBeacon.sol\";\nimport { Ownable } from \"@openzeppelin/contracts/access/Ownable.sol\";\n\ncontract ETSRelayerBeacon is Ownable {\n    UpgradeableBeacon immutable relayerBeacon;\n\n    address public relayerLogic;\n\n    constructor(address _relayerLogic) {\n        relayerBeacon = new UpgradeableBeacon(_relayerLogic);\n        relayerLogic = _relayerLogic;\n        // Assigns ownership to deployer.\n        transferOwnership(tx.origin);\n    }\n\n    function update(address _relayerLogic) public onlyOwner {\n        relayerBeacon.upgradeTo(_relayerLogic);\n        relayerLogic = _relayerLogic;\n    }\n\n    function implementation() public view returns (address) {\n        return relayerBeacon.implementation();\n    }\n}\n"
    },
    "contracts/relayers/ETSRelayerV1.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\n/**\n * @title ETS Relayer Version 1\n * @author Ethereum Tag Service <team@ets.xyz>\n *\n *  \n *  \n *          \n *          \n *        \n *        \n *\n * @notice Version 1 of upgradeable beacon proxy contract pointed to by ETSRelayerBeacon.sol\n */\n\npragma solidity ^0.8.10;\n\nimport { IETS } from \"../interfaces/IETS.sol\";\nimport { IETSToken } from \"../interfaces/IETSToken.sol\";\nimport { IETSTarget } from \"../interfaces/IETSTarget.sol\";\nimport { IETSRelayer } from \"./interfaces/IETSRelayer.sol\";\nimport { IETSAccessControls } from \"../interfaces/IETSAccessControls.sol\";\nimport { UintArrayUtils } from \"../libraries/UintArrayUtils.sol\";\n\nimport { Initializable } from \"@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol\";\nimport { ReentrancyGuardUpgradeable } from \"@openzeppelin/contracts-upgradeable/security/ReentrancyGuardUpgradeable.sol\";\nimport { ERC165Upgradeable } from \"@openzeppelin/contracts-upgradeable/utils/introspection/ERC165Upgradeable.sol\";\nimport { OwnableUpgradeable } from \"@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol\";\nimport { PausableUpgradeable } from \"@openzeppelin/contracts-upgradeable/security/PausableUpgradeable.sol\";\n\ncontract ETSRelayerV1 is\n    IETSRelayer,\n    Initializable,\n    ERC165Upgradeable,\n    OwnableUpgradeable,\n    PausableUpgradeable,\n    ReentrancyGuardUpgradeable\n{\n    using UintArrayUtils for uint256[];\n\n    /// @dev Address and interface for ETS Core.\n    IETS public ets;\n\n    /// @dev Address and interface for ETS Token\n    IETSToken public etsToken;\n\n    /// @dev Address and interface for ETS Target.\n    IETSTarget public etsTarget;\n\n    /// @dev Address and interface for ETS Access Controls.\n    IETSAccessControls public etsAccessControls;\n\n    // Public constants\n    string public constant NAME = \"ETS Relayer\";\n    string public constant VERSION = \"0.1-Beta\";\n    bytes4 public constant IID_IETSRELAYER = type(IETSRelayer).interfaceId;\n\n    // Public variables\n\n    /// @notice Address that built this smart contract.\n    address payable public creator;\n\n    /// @dev Public name for Relayer instance.\n    string public relayerName;\n\n    /// Modifiers\n    modifier onlyRelayerAdmin() {\n        require(\n            _msgSender() == owner() || etsAccessControls.hasRole(keccak256(\"RELAYER_ADMIN_ROLE\"), _msgSender()),\n            \"Caller not relayer admin\"\n        );\n        _;\n    }\n\n    /// @custom:oz-upgrades-unsafe-allow constructor\n    constructor() {\n        _disableInitializers();\n    }\n\n    function initialize(\n        string memory _relayerName,\n        IETS _ets,\n        IETSToken _etsToken,\n        IETSTarget _etsTarget,\n        IETSAccessControls _etsAccessControls,\n        address payable _creator,\n        address payable _owner\n    ) public initializer {\n        __Pausable_init();\n        __Ownable_init();\n        __ReentrancyGuard_init();\n        relayerName = _relayerName;\n        ets = _ets;\n        etsToken = _etsToken;\n        etsTarget = _etsTarget;\n        etsAccessControls = _etsAccessControls;\n        creator = _creator;\n        transferOwnership(_owner);\n    }\n\n    // ============ OWNER INTERFACE ============\n\n    /// @inheritdoc IETSRelayer\n    function pause() public onlyRelayerAdmin {\n        _pause();\n        emit RelayerPauseToggledByOwner(address(this));\n    }\n\n    /// @inheritdoc IETSRelayer\n    function unpause() public onlyRelayerAdmin {\n        // Check that relayer is not paused by platform.\n        require(!etsAccessControls.isRelayerLocked(address(this)), \"Unpausing not permitted\");\n        require(etsToken.balanceOf(owner()) > 0, \"Owner must hold CTAG\");\n        _unpause();\n        emit RelayerPauseToggledByOwner(address(this));\n    }\n\n    /// @inheritdoc IETSRelayer\n    function changeOwner(address _newOwner) public whenPaused onlyOwner {\n        // TODO: check that new owner doesn't already have relayer?\n        etsAccessControls.changeRelayerOwner(owner(), _newOwner);\n        transferOwnership(_newOwner);\n        emit RelayerOwnerChanged(address(this));\n    }\n\n    // ============ PUBLIC INTERFACE ============\n\n    /// @inheritdoc IETSRelayer\n    function applyTags(IETS.TaggingRecordRawInput[] calldata _rawInput) public payable whenNotPaused {\n        uint256 taggingFee = ets.taggingFee();\n        for (uint256 i; i < _rawInput.length; ++i) {\n            _applyTags(_rawInput[i], payable(msg.sender), taggingFee);\n        }\n    }\n\n    /// @inheritdoc IETSRelayer\n    function replaceTags(IETS.TaggingRecordRawInput[] calldata _rawInput) public payable whenNotPaused {\n        uint256 taggingFee = ets.taggingFee();\n        for (uint256 i; i < _rawInput.length; ++i) {\n            _replaceTags(_rawInput[i], payable(msg.sender), taggingFee);\n        }\n    }\n\n    /// @inheritdoc IETSRelayer\n    function removeTags(IETS.TaggingRecordRawInput[] calldata _rawInput) public payable whenNotPaused {\n        for (uint256 i; i < _rawInput.length; ++i) {\n            _removeTags(_rawInput[i], payable(msg.sender));\n        }\n    }\n\n    /// @inheritdoc IETSRelayer\n    function getOrCreateTagIds(\n        string[] calldata _tags\n    ) public payable whenNotPaused returns (uint256[] memory _tagIds) {\n        // First let's derive tagIds for the tagStrings.\n        uint256[] memory tagIds = new uint256[](_tags.length);\n        for (uint256 i; i < _tags.length; ++i) {\n            // for new CTAGs msg.sender is logged as \"creator\" and this contract is \"relayer\"\n            tagIds[i] = ets.getOrCreateTagId(_tags[i], payable(msg.sender));\n        }\n        return tagIds;\n    }\n\n    // ============ PUBLIC VIEW FUNCTIONS ============\n\n    function version() external view virtual returns (string memory) {\n        return VERSION;\n    }\n\n    /// @inheritdoc ERC165Upgradeable\n    function supportsInterface(\n        bytes4 interfaceId\n    ) public view virtual override(ERC165Upgradeable, IETSRelayer) returns (bool) {\n        return interfaceId == IID_IETSRELAYER || super.supportsInterface(interfaceId);\n    }\n\n    /// @inheritdoc IETSRelayer\n    function isPaused() public view virtual returns (bool) {\n        return paused();\n    }\n\n    /// @inheritdoc IETSRelayer\n    function getOwner() public view virtual returns (address payable) {\n        return payable(owner());\n    }\n\n    /// @inheritdoc IETSRelayer\n    function getRelayerName() public view returns (string memory) {\n        return relayerName;\n    }\n\n    /// @inheritdoc IETSRelayer\n    function getCreator() public view returns (address payable) {\n        return creator;\n    }\n\n    /// @inheritdoc IETSRelayer\n    function computeTaggingFee(\n        IETS.TaggingRecordRawInput calldata _rawInput,\n        IETS.TaggingAction _action\n    ) public view returns (uint256 fee, uint256 tagCount) {\n        return ets.computeTaggingFeeFromRawInput(_rawInput, address(this), msg.sender, _action);\n    }\n\n    function getBalance() public view returns (uint) {\n        return address(this).balance;\n    }\n\n    // ============ INTERNAL FUNCTIONS ============\n\n    function _applyTags(\n        IETS.TaggingRecordRawInput calldata _rawInput,\n        address payable _tagger,\n        uint256 _taggingFee\n    ) internal {\n        uint256 valueToSendForTagging = 0;\n        if (_taggingFee > 0) {\n            // This is either a new tagging record or an existing record that's being appended to.\n            // Either way, we need to assess the tagging fees.\n            uint256 actualTagCount = 0;\n            (valueToSendForTagging, actualTagCount) = ets.computeTaggingFeeFromRawInput(\n                _rawInput,\n                address(this),\n                _tagger,\n                IETS.TaggingAction.APPEND\n            );\n            require(address(this).balance >= valueToSendForTagging, \"Insufficient funds\");\n        }\n\n        // Call the core applyTagsWithRawInput() function to record new or append to exsiting tagging record.\n        ets.applyTagsWithRawInput{ value: valueToSendForTagging }(_rawInput, _tagger);\n    }\n\n    function _replaceTags(\n        IETS.TaggingRecordRawInput calldata _rawInput,\n        address payable _tagger,\n        uint256 _taggingFee\n    ) internal {\n        uint256 valueToSendForTagging = 0;\n        if (_taggingFee > 0) {\n            // This is either a new tagging record or an existing record that's being appended to.\n            // Either way, we need to assess the tagging fees.\n            uint256 actualTagCount = 0;\n            (valueToSendForTagging, actualTagCount) = ets.computeTaggingFeeFromRawInput(\n                _rawInput,\n                address(this),\n                _tagger,\n                IETS.TaggingAction.REPLACE\n            );\n            require(address(this).balance >= valueToSendForTagging, \"Insufficient funds\");\n        }\n\n        // Finally, call the core replaceTags() function to update the tagging record.\n        ets.replaceTagsWithRawInput{ value: valueToSendForTagging }(_rawInput, _tagger);\n    }\n\n    function _removeTags(IETS.TaggingRecordRawInput calldata _rawInput, address payable _tagger) internal {\n        ets.removeTagsWithRawInput(_rawInput, _tagger);\n    }\n\n    /* solhint-disable */\n    receive() external payable {}\n\n    fallback() external payable {}\n    /* solhint-enable */\n}\n"
    },
    "contracts/relayers/interfaces/IETSRelayer.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\n/**\n * @title IETSRelayer\n * @author Ethereum Tag Service <team@ets.xyz>\n *\n *  \n *  \n *          \n *          \n *        `\n *        \n *\n * @notice Minimum interface required for ETS Relayer proxy.\n */\n\npragma solidity ^0.8.10;\n\nimport { IETS } from \"../../interfaces/IETS.sol\";\n\ninterface IETSRelayer {\n    /**\n     * @dev Emitted when an IETSRelayer contract is paused/unpaused by owner.\n     *\n     * @param relayerAddress Address of relayer contract.\n     */\n    event RelayerPauseToggledByOwner(address relayerAddress);\n\n    /**\n     * @dev Emitted when an IETSRelayer contract has changed owners.\n     *\n     * @param relayerAddress Address of relayer contract.\n     */\n    event RelayerOwnerChanged(address relayerAddress);\n\n    // ============ OWNER INTERFACE ============\n\n    /**\n     * @notice Pause this relayer contract.\n     * @dev This function can only be called by the owner when the contract is unpaused.\n     */\n    function pause() external;\n\n    /**\n     * @notice Unpause this relayer contract.\n     * @dev This function can only be called by the owner when the contract is paused.\n     */\n    function unpause() external;\n\n    /**\n     * @notice Transfer this contract to a new owner.\n     *\n     * @dev This function can only be called by the owner when the contract is paused.\n     *\n     * @param newOwner Address of the new contract owner.\n     */\n    function changeOwner(address newOwner) external;\n\n    // ============ PUBLIC VIEW FUNCTIONS ============\n\n    /**\n     * @notice Broadcast support for IETSRelayer interface to external contracts.\n     *\n     * @dev ETSCore will only add relayer contracts that implement IETSRelayer interface.\n     * Your implementation should broadcast that it implements IETSRelayer interface.\n     *\n     * @return boolean: true if this contract implements the interface defined by\n     * `interfaceId`\n     */\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\n\n    /**\n     * @notice Check whether this contract has been pasued by the owner.\n     *\n     * @dev Pause functionality should be provided by OpenZeppelin Pausable utility.\n     * @return boolean: true for paused; false for not paused.\n     */\n    function isPaused() external view returns (bool);\n\n    /**\n     * @notice Returns address of an IETSRelayer contract owner.\n     *\n     * @return address of contract owner.\n     */\n    function getOwner() external view returns (address payable);\n\n    /**\n     * @notice Returns human readable name for this IETSRelayer contract.\n     *\n     * @return name of the Relayer contract as a string.\n     */\n    function getRelayerName() external view returns (string memory);\n\n    /**\n     * @notice Returns address of an IETSRelayer contract creator.\n     *\n     * @return address of the creator of the Relayer contract.\n     */\n    function getCreator() external view returns (address payable);\n\n    /**\n     * @notice Apply one or more tags to a targetURI using tagging record raw client input data.\n     *\n     * @param _rawInput Raw client input data formed as TaggingRecordRawInput struct.\n     */\n    function applyTags(IETS.TaggingRecordRawInput[] calldata _rawInput) external payable;\n\n    /**\n     * @notice Replace entire tag set in tagging record using raw data for record lookup.\n     *\n     * If supplied tag strings don't have CTAGs, new ones are minted.\n     *\n     * @param _rawInput Raw client input data formed as TaggingRecordRawInput struct.\n     */\n    function replaceTags(IETS.TaggingRecordRawInput[] calldata _rawInput) external payable;\n\n    /**\n     * @notice Remove one or more tags from a tagging record using raw data for record lookup.\n     *\n     * @param _rawInput Raw client input data formed as TaggingRecordRawInput struct.\n     */\n    function removeTags(IETS.TaggingRecordRawInput[] calldata _rawInput) external payable;\n\n    /**\n     * @notice Get or create CTAG tokens from tag strings.\n     *\n     * Combo function that accepts a tag strings and returns corresponding CTAG token Id if it exists,\n     * or if it doesn't exist, creates a new CTAG and then returns corresponding Id.\n     *\n     * Only ETS Publisher contracts may call this function.\n     *\n     * @param _tags Array of tag strings.\n     * @return _tagIds Array of Id of CTAG Ids.\n     */\n    function getOrCreateTagIds(string[] calldata _tags) external payable returns (uint256[] memory _tagIds);\n\n    /**\n     * @notice Compute tagging fee for raw input and desired action.\n     *\n     * @param _rawInput Raw client input data formed as TaggingRecordRawInput struct.\n     * @param _action Integer representing action to be performed according to enum TaggingAction.\n     *\n     * @return fee Calculated tagging fee in ETH/Matic\n     * @return tagCount Number of new tags being added to tagging record.\n     */\n    function computeTaggingFee(\n        IETS.TaggingRecordRawInput calldata _rawInput,\n        IETS.TaggingAction _action\n    ) external view returns (uint256 fee, uint256 tagCount);\n}\n"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": true,
      "runs": 1000
    },
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "devdoc",
          "userdoc",
          "storageLayout",
          "evm.gasEstimates"
        ],
        "": [
          "ast"
        ]
      }
    },
    "metadata": {
      "useLiteralContent": true
    }
  }
}